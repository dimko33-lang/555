<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>SR Visualization</title>
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
<style>
  body {
    margin:0;
    background:#000833;
    overflow:hidden;
    touch-action: none;
    font-family: Arial, sans-serif;
  }
  canvas {
    display:block;
    position: absolute;
    top: 0;
    left: 0;
    z-index: 1;
  }

  /* –ö–Ω–æ–ø–∫–∏ —É–ø—Ä–∞–≤–ª–µ–Ω–∏—è –≤ —Ä—è–¥ */
  .controls {
    position: fixed;
    top: 10px;
    right: 10px;
    display: flex;
    gap: 6px;
    flex-wrap: nowrap;
    justify-content: flex-end;
    max-width: 180px;
    z-index: 100;
  }
  .btn {
    width: 44px;
    height: 44px;
    border-radius: 5px;
    background: rgba(0,0,0,0.7);
    border: 1px solid rgba(255,255,255,0.3);
    color: white;
    font-size: 22px;
    cursor: pointer;
    display: flex;
    align-items: center;
    justify-content: center;
    user-select: none;
    transition: all 0.2s;
    flex-shrink: 0;
  }
  .btn:hover {
    background: rgba(50,50,50,0.9);
  }
  .btn:active {
    transform: scale(0.95);
  }

  /* –ü–∞–Ω–µ–ª—å –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏–∏ - –ø–æ–¥–æ–≥–Ω–∞–Ω–∞ –ø–æ –≤—ã—Å–æ—Ç–µ –ø–æ–¥ –∫–Ω–æ–ø–∫–∏ */
  .info-panel {
    position: fixed;
    top: 10px;
    left: 10px;
    background: rgba(0,0,0,0.7);
    color: white;
    padding: 0 15px;
    border-radius: 5px;
    font-size: 14px;
    border: 1px solid rgba(255,255,255,0.2);
    min-width: 200px;
    height: 44px;
    z-index: 100;
    display: flex;
    flex-direction: column;
    justify-content: center;
  }
  .info-item {
    margin: 0;
    display: flex;
    justify-content: space-between;
    align-items: center;
  }
  .info-label {
    color: #aaa;
    font-size: 11px;
  }
  .info-value {
    font-weight: bold;
    font-family: 'Courier New', monospace;
  }
  .speed-value {
    color: #fa0;
    font-size: 14px;
  }
  .gamma-value {
    color: #0ff;
    font-size: 14px;
  }

  /* –°—Ç–∏–ª–∏ –¥–ª—è —Å–≤–µ—Ç–ª–æ–≥–æ —Ä–µ–∂–∏–º–∞ */
  body.light-mode {
    background: #fff;
  }
  body.light-mode .btn {
    background: rgba(255,255,255,0.7);
    border: 1px solid rgba(0,0,0,0.3);
    color: #000;
  }
  body.light-mode .info-panel {
    background: rgba(255,255,255,0.9);
    color: #000;
    border: 1px solid rgba(0,0,0,0.2);
  }
  body.light-mode .info-label {
    color: #666;
  }
</style>
</head>
<body>
<canvas id="c"></canvas>

<!-- –ü–∞–Ω–µ–ª—å –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏–∏ -->
<div class="info-panel" id="infoPanel">
  <div class="info-item">
    <span class="info-label">Speed:</span>
    <span class="info-value speed-value" id="speedValue">0.000c</span>
  </div>
  <div class="info-item">
    <span class="info-label">Œ≥:</span>
    <span class="info-value gamma-value" id="gammaValue">1.000</span>
  </div>
</div>

<!-- –ö–Ω–æ–ø–∫–∏ —É–ø—Ä–∞–≤–ª–µ–Ω–∏—è -->
<div class="controls">
  <!-- –ù–û–í–ê–Ø –ö–ù–û–ü–ö–ê -->
  <button class="btn" id="modeBtn" title="Switch mode">M</button>
  <button class="btn" id="negBtn" title="Negative/Invert">‚òÄ</button>
  <button class="btn" id="zoomReset" title="Reset scale">‚Üª</button>
  <button class="btn" id="fullscreen" title="Fullscreen mode">‚õ∂</button>
</div>

<script>
// =============== –ù–ê–ß–ê–õ–û –í–ê–®–ï–ì–û –ò–°–•–û–î–ù–û–ì–û –°–ö–†–ò–ü–¢–ê ===============
const canvas = document.getElementById("c");
const ctx = canvas.getContext("2d");

let angle = 0;
let dragging = false;
let lastX = 0;
let scale = 0.3;
let offsetX = 0, offsetY = 0;
let darkMode = true;
// –ï–î–ò–ù–°–¢–í–ï–ù–ù–û–ï –î–û–ë–ê–í–õ–ï–ù–ò–ï: –ø–µ—Ä–µ–º–µ–Ω–Ω–∞—è –¥–ª—è —Ä–µ–∂–∏–º–∞
let minkowskiMode = false;

const numLines = 21;
const secondsPerSide = 10;
const vertLineLength = 3000;

const TARGET_GAMMA = 1000000.000;
const TARGET_V = Math.sqrt(1 - 1/(TARGET_GAMMA * TARGET_GAMMA));
const MAX_ANGLE = Math.asin(TARGET_V);

let touchStartDistance = null;
let touchStartAngle = null;
let touchStartCenterX = 0;
let touchStartCenterY = 0;
let touchStartScale = 0.3;
let touchStartAngleSystem = 0;
let touchStartOffsetX = 0;
let touchStartOffsetY = 0;
let touchStartWorldX = 0;
let touchStartWorldY = 0;

const lineSpacing = vertLineLength / (numLines - 1);
const halfSpacing = lineSpacing / 2;
const smallSpacing = lineSpacing / 10;

function getTouchDistance(touches) {
  const dx = touches[0].clientX - touches[1].clientX;
  const dy = touches[0].clientY - touches[1].clientY;
  return Math.sqrt(dx * dx + dy * dy);
}

function getTouchAngle(touches) {
  const dx = touches[0].clientX - touches[1].clientX;
  const dy = touches[0].clientY - touches[1].clientY;
  return Math.atan2(dy, dx);
}

canvas.addEventListener('touchstart', (e) => {
  e.preventDefault();
  if (e.touches.length === 2) {
    const rect = canvas.getBoundingClientRect();
    const touch1 = e.touches[0];
    const touch2 = e.touches[1];
    touchStartDistance = getTouchDistance(e.touches);
    touchStartAngle = getTouchAngle(e.touches);
    touchStartCenterX = (touch1.clientX + touch2.clientX) / 2 - rect.left;
    touchStartCenterY = (touch1.clientY + touch2.clientY) / 2 - rect.top;
    touchStartScale = scale;
    touchStartAngleSystem = angle;
    touchStartOffsetX = offsetX;
    touchStartOffsetY = offsetY;
    touchStartWorldX = (touchStartCenterX - touchStartOffsetX) / touchStartScale;
    touchStartWorldY = (touchStartCenterY - touchStartOffsetY) / touchStartScale;
    dragging = false;
  } else if (e.touches.length === 1) {
    dragging = true;
    lastX = e.touches[0].clientX;
  }
}, { passive: false });

canvas.addEventListener('touchmove', (e) => {
  e.preventDefault();
  if (e.touches.length === 2 && touchStartDistance !== null && touchStartDistance > 0) {
    const rect = canvas.getBoundingClientRect();
    const touch1 = e.touches[0];
    const touch2 = e.touches[1];
    const currentDistance = getTouchDistance(e.touches);
    const currentAngle = getTouchAngle(e.touches);
    const currentCenterX = (touch1.clientX + touch2.clientX) / 2 - rect.left;
    const currentCenterY = (touch1.clientY + touch2.clientY) / 2 - rect.top;
    const zoomFactor = currentDistance / touchStartDistance;
    const newScale = Math.max(0.1, Math.min(5, touchStartScale * zoomFactor));
    const angleDelta = currentAngle - touchStartAngle;
    let newAngle = touchStartAngleSystem - angleDelta * 0.8;
    newAngle = Math.max(-MAX_ANGLE, Math.min(MAX_ANGLE, newAngle));
    const newOffsetX = currentCenterX - touchStartWorldX * newScale;
    const newOffsetY = currentCenterY - touchStartWorldY * newScale;
    scale = newScale;
    angle = newAngle;
    offsetX = newOffsetX;
    offsetY = newOffsetY;
    updateInfo();
  } else if (e.touches.length === 1 && dragging) {
    const dx = e.touches[0].clientX - lastX;
    angle += dx * 0.01;
    angle = Math.max(-MAX_ANGLE, Math.min(MAX_ANGLE, angle));
    lastX = e.touches[0].clientX;
    updateInfo();
  }
}, { passive: false });

canvas.addEventListener('touchend', (e) => {
  dragging = false;
  if (e.touches.length < 2) {
    touchStartDistance = null;
    touchStartAngle = null;
  }
});

canvas.addEventListener("pointerdown", e => {
  dragging = true;
  lastX = e.clientX;
});

canvas.addEventListener("pointermove", e => {
  if(dragging){
    const dx = e.clientX - lastX;
    angle += dx * 0.01;
    angle = Math.max(-MAX_ANGLE, Math.min(MAX_ANGLE, angle));
    lastX = e.clientX;
    updateInfo();
  }
});

canvas.addEventListener("pointerup", e => dragging = false);
canvas.addEventListener("pointerleave", e => dragging = false);

canvas.addEventListener("wheel", e => {
  e.preventDefault();
  const zoomFactor = 1.1;
  const rect = canvas.getBoundingClientRect();
  const mouseX = e.clientX - rect.left;
  const mouseY = e.clientY - rect.top;
  const worldX = (mouseX - offsetX) / scale;
  const worldY = (mouseY - offsetY) / scale;
  if (e.deltaY < 0) {
    scale *= zoomFactor;
  } else {
    scale /= zoomFactor;
  }
  scale = Math.max(0.1, Math.min(5, scale));
  offsetX = mouseX - worldX * scale;
  offsetY = mouseY - worldY * scale;
});

// ========== –û–ë–†–ê–ë–û–¢–ß–ò–ö–ò –ö–ù–û–ü–û–ö ==========
// 1. –û–ë–†–ê–ë–û–¢–ß–ò–ö –î–õ–Ø –ù–û–í–û–ô –ö–ù–û–ü–ö–ò (–ü–†–û–°–¢–û –ú–ï–ù–Ø–ï–¢ –¢–ï–ö–°–¢)
document.getElementById('modeBtn').addEventListener('click', () => {
  minkowskiMode = !minkowskiMode;
  const btn = document.getElementById('modeBtn');
  btn.textContent = minkowskiMode ? 'G' : 'M';
  btn.title = minkowskiMode ? 'Standard Geometry' : 'Minkowski Diagram';
  // –ü–æ–∫–∞ —á—Ç–æ —Ç–æ–ª—å–∫–æ –º–µ–Ω—è–µ—Ç –Ω–∞–¥–ø–∏—Å—å. –î–∏–∞–≥—Ä–∞–º–º—É –¥–æ–±–∞–≤–∏–º, –∫–æ–≥–¥–∞ –≤—Å—ë –∑–∞—Ä–∞–±–æ—Ç–∞–µ—Ç.
  console.log("–†–µ–∂–∏–º –∏–∑–º–µ–Ω—ë–Ω –Ω–∞:", minkowskiMode ? "–ú–∏–Ω–∫–æ–≤—Å–∫–∏–π" : "–ì–µ–æ–º–µ—Ç—Ä–∏—è");
});

// 2. –í–ê–®–ò –°–¢–ê–†–´–ï –û–ë–†–ê–ë–û–¢–ß–ò–ö–ò (–ë–ï–ó –ò–ó–ú–ï–ù–ï–ù–ò–ô)
document.getElementById('negBtn').addEventListener('click', () => {
  darkMode = !darkMode;
  document.body.classList.toggle('light-mode', !darkMode);
  document.getElementById('negBtn').textContent = darkMode ? '‚òÄ' : 'üåô';
});

document.getElementById('zoomReset').addEventListener('click', () => {
  scale = 0.3;
  offsetX = canvas.width/2;
  offsetY = canvas.height/2;
});

document.getElementById('fullscreen').addEventListener('click', () => {
  if (!document.fullscreenElement) {
    document.documentElement.requestFullscreen().catch(err => {
      console.error(`Fullscreen error: ${err.message}`);
    });
  } else {
    document.exitFullscreen();
  }
});

// ========== –í–°–ü–û–ú–û–ì–ê–¢–ï–õ–¨–ù–´–ï –§–£–ù–ö–¶–ò–ò (–í–ê–®–ò –ë–ï–ó –ò–ó–ú–ï–ù–ï–ù–ò–ô) ==========
function updateInfo() {
  const velocity = Math.sin(angle);
  let velocityStr;
  if (Math.abs(velocity) < 0.0001) {
    velocityStr = "0.000c";
  } else {
    const absV = Math.abs(velocity);
    if (Math.abs(Math.abs(angle) - MAX_ANGLE) < 0.0000001) {
      velocityStr = TARGET_V.toFixed(12) + "c";
    } else if (absV > 0.999999) {
      velocityStr = absV.toFixed(12) + "c";
    } else if (absV > 0.999) {
      velocityStr = absV.toFixed(9) + "c";
    } else if (absV > 0.99) {
      velocityStr = absV.toFixed(6) + "c";
    } else {
      velocityStr = absV.toFixed(3) + "c";
    }
    if (velocity < 0) velocityStr = "-" + velocityStr;
  }

  let gamma = 1;
  const v = Math.abs(velocity);
  if (v < 0.999999999999) {
    gamma = 1 / Math.sqrt(1 - v * v);
  } else {
    gamma = TARGET_GAMMA;
  }

  let gammaStr;
  if (Math.abs(Math.abs(angle) - MAX_ANGLE) < 0.0000001) {
    gammaStr = TARGET_GAMMA.toFixed(3);
  } else if (gamma >= 1000) {
    gammaStr = gamma.toFixed(3);
  } else {
    gammaStr = gamma.toFixed(3);
  }

  document.getElementById('speedValue').textContent = velocityStr;
  document.getElementById('gammaValue').textContent = gammaStr;

  const speedValue = document.getElementById('speedValue');
  const absV = Math.abs(velocity);
  if (absV < 0.3) {
    speedValue.style.color = darkMode ? '#0f0' : '#080';
  } else if (absV < 0.7) {
    speedValue.style.color = darkMode ? '#ff0' : '#880';
  } else if (absV < 0.95) {
    speedValue.style.color = darkMode ? '#f80' : '#c60';
  } else {
    speedValue.style.color = darkMode ? '#f00' : '#c00';
  }
}

function resize() {
  canvas.width = window.innerWidth;
  canvas.height = window.innerHeight;
  offsetX = canvas.width/2;
  offsetY = canvas.height/2;
}
window.addEventListener("resize", resize);
resize();

function toScreen(x, y) {
  return {
    x: x * scale + offsetX,
    y: y * scale + offsetY
  };
}

function getColor(darkColor, lightColor) {
  return darkMode ? darkColor : lightColor;
}

function drawLine(x1, y1, x2, y2, darkColor, lightColor, width) {
  const p1 = toScreen(x1, y1);
  const p2 = toScreen(x2, y2);
  ctx.strokeStyle = getColor(darkColor, lightColor);
  ctx.lineWidth = width;
  ctx.beginPath();
  ctx.moveTo(p1.x, p1.y);
  ctx.lineTo(p2.x, p2.y);
  ctx.stroke();
}

function drawMark(px, py, dirX, dirY, length, darkColor, lightColor, width, style = "solid") {
  const p = toScreen(px, py);
  const d = toScreen(px + dirX * length/2, py + dirY * length/2);
  const d2 = toScreen(px - dirX * length/2, py - dirY * length/2);
  ctx.strokeStyle = getColor(darkColor, lightColor);
  ctx.lineWidth = width;
  if (style === "dashed") {
    ctx.setLineDash([3, 2]);
  } else {
    ctx.setLineDash([]);
  }
  ctx.beginPath();
  ctx.moveTo(d2.x, d2.y);
  ctx.lineTo(d.x, d.y);
  ctx.stroke();
  ctx.setLineDash([]);
}

function drawPoint(px, py, radius, darkColor, lightColor) {
  const p = toScreen(px, py);
  ctx.fillStyle = getColor(darkColor, lightColor);
  ctx.beginPath();
  ctx.arc(p.x, p.y, radius, 0, Math.PI * 2);
  ctx.fill();
}

function drawText(text, px, py, darkColor, lightColor, fontSize = 10, align = "center") {
  if (scale < 0.5) return;
  const p = toScreen(px, py);
  ctx.font = `${fontSize}px Arial`;
  ctx.fillStyle = getColor(darkColor, lightColor);
  ctx.textAlign = align;
  ctx.textBaseline = "middle";
  ctx.fillText(text, p.x, p.y);
}

// ========== –ì–õ–ê–í–ù–ê–Ø –§–£–ù–ö–¶–ò–Ø –û–¢–†–ò–°–û–í–ö–ò ==========
function draw() {
  // –û—á–∏—Å—Ç–∫–∞
  if (darkMode) {
    ctx.fillStyle = "#000833";
  } else {
    ctx.fillStyle = "#fff";
  }
  ctx.fillRect(0, 0, canvas.width, canvas.height);

  // –°–µ–π—á–∞—Å –æ—Ç—Ä–∏—Å–æ–≤—ã–≤–∞–µ—Ç—Å—è –¢–û–õ–¨–ö–û –≤–∞—à–∞ —Å—Ç–∞—Ä–∞—è –≥–µ–æ–º–µ—Ç—Ä–∏—è.
  // –£—Å–ª–æ–≤–∏–µ if (minkowskiMode) –¥–æ–±–∞–≤–ª—é –≤ —Å–ª–µ–¥—É—é—â–µ–º —à–∞–≥–µ.
  const cx = 0;
  const cy = 0;
  const cosA = Math.cos(angle);
  const sinA = Math.sin(angle);
  drawLine(-vertLineLength, cy, vertLineLength, cy, "#0ff", "#08f", 1);
  const ctX0 = cx - sinA * vertLineLength/2;
  const ctY0 = cy - cosA * vertLineLength/2;
  const ctX1 = cx + sinA * vertLineLength/2;
  const ctY1 = cy + cosA * vertLineLength/2;
  const xX0 = cx - cosA * vertLineLength/2;
  const xY0 = cy + sinA * vertLineLength/2;
  const xX1 = cx + cosA * vertLineLength/2;
  const xY1 = cy - sinA * vertLineLength/2;
  drawLine(ctX0, ctY0, ctX1, ctY1, "#0ff", "#08f", 1);
  drawLine(xX0, xY0, xX1, xY1, "#888", "#666", 1);
  const ctDirX = ctX1 - ctX0;
  const ctDirY = ctY1 - ctY0;
  const ctLength = Math.sqrt(ctDirX*ctDirX + ctDirY*ctDirY);
  const ctUnitX = ctDirX / ctLength;
  const ctUnitY = ctDirY / ctLength;
  const ctPerpX = -ctUnitY;
  const ctPerpY = ctUnitX;
  const xDirX = xX1 - xX0;
  const xDirY = xY1 - xY0;
  const xLength = Math.sqrt(xDirX*xDirX + xDirY*xDirY);
  const xUnitX = xDirX / xLength;
  const xUnitY = xDirY / xLength;
  const xPerpX = -xUnitY;
  const xPerpY = xUnitX;

  for(let sec = 1; sec <= secondsPerSide; sec++) {
    const distance = sec * lineSpacing;
    const bigX1 = distance * ctUnitX;
    const bigY1 = distance * ctUnitY;
    drawMark(bigX1, bigY1, ctPerpX, ctPerpY, 14, "#0ff", "#08f", 1.5);
    if (scale > 0.5) {
      drawText((-sec).toString(), bigX1 + ctPerpX * 15, bigY1 + ctPerpY * 15, "#0ff", "#08f", 10);
    }
    const bigX2 = -distance * ctUnitX;
    const bigY2 = -distance * ctUnitY;
    drawMark(bigX2, bigY2, ctPerpX, ctPerpY, 14, "#0ff", "#08f", 1.5);
    if (scale > 0.5) {
      drawText(sec.toString(), bigX2 - ctPerpX * 15, bigY2 - ctPerpY * 15, "#0ff", "#08f", 10);
    }
    const halfDistance = distance - halfSpacing;
    const halfX1 = halfDistance * ctUnitX;
    const halfY1 = halfDistance * ctUnitY;
    drawMark(halfX1, halfY1, ctPerpX, ctPerpY, 10, "#0aa", "#06a", 1.0, "dashed");
    const halfX2 = -halfDistance * ctUnitX;
    const halfY2 = -halfDistance * ctUnitY;
    drawMark(halfX2, halfY2, ctPerpX, ctPerpY, 10, "#0aa", "#06a", 1.0, "dashed");
  }

  const smallMarksPerSide = secondsPerSide * 10;
  for(let tenth = 1; tenth <= smallMarksPerSide; tenth++) {
    if (tenth % 5 === 0) continue;
    const distance = tenth * smallSpacing;
    const smallX1 = distance * ctUnitX;
    const smallY1 = distance * ctUnitY;
    drawPoint(smallX1, smallY1, 2, "#099", "#057");
    const smallX2 = -distance * ctUnitX;
    const smallY2 = -distance * ctUnitY;
    drawPoint(smallX2, smallY2, 2, "#099", "#057");
  }

  for(let i = -10; i <= 10; i++){
    const t = i / 10;
    const px = xX0 + (xX1 - xX0) * (0.5 + t/2);
    const py = xY0 + (xY1 - xY0) * (0.5 + t/2);
    drawLine(px, py - vertLineLength/2, px, py + vertLineLength/2, "#888", "#666", 1);
    for(let sec = 1; sec <= secondsPerSide; sec++) {
      const distance = sec * lineSpacing;
      const upX = px;
      const upY = py - distance;
      drawMark(upX, upY, 1, 0, 12, "#888", "#666", 1.5);
      if (scale > 0.5) {
        drawText(sec.toString(), upX - 8, upY, "#888", "#666", 10, "right");
      }
      const downX = px;
      const downY = py + distance;
      drawMark(downX, downY, 1, 0, 12, "#888", "#666", 1.5);
      if (scale > 0.5) {
        drawText((-sec).toString(), downX + 8, downY, "#888", "#666", 10, "left");
      }
      const halfDistance = distance - halfSpacing;
      const halfUpX = px;
      const halfUpY = py - halfDistance;
      drawMark(halfUpX, halfUpY, 1, 0, 9, "#888", "#666", 1.0, "dashed");
      const halfDownX = px;
      const halfDownY = py + halfDistance;
      drawMark(halfDownX, halfDownY, 1, 0, 9, "#888", "#666", 1.0, "dashed");
    }
    for(let tenth = 1; tenth <= secondsPerSide * 10; tenth++) {
      if (tenth % 5 === 0) continue;
      const distance = tenth * smallSpacing;
      const upX = px;
      const upY = py - distance;
      drawPoint(upX, upY, 1.5, "#888", "#666");
      const downX = px;
      const downY = py + distance;
      drawPoint(downX, downY, 1.5, "#888", "#666");
    }
    if (scale > 0.7 && i !== 0) {
      drawText(i.toString(), px, py + 20, "#888", "#666", 10);
    }
  }

  const center = toScreen(0, 0);
  ctx.fillStyle = getColor("#fff", "#000");
  ctx.beginPath();
  ctx.arc(center.x, center.y, 4, 0, Math.PI * 2);
  ctx.fill();

  requestAnimationFrame(draw);
}
// =============== –ö–û–ù–ï–¶ –í–ê–®–ï–ì–û –ò–°–•–û–î–ù–û–ì–û –°–ö–†–ò–ü–¢–ê ===============

// –ó–∞–ø—É—Å–∫
resize();
updateInfo();
draw();
</script>
</body>
  </html>
