<!DOCTYPE html>
<html lang="ru">
<head>
<meta charset="UTF-8">
<title>СТО: крест с тонкой x′</title>
<style>
  body { margin:0; background:#111; overflow:hidden; touch-action: none; }
  canvas { display:block; }
</style>
<body>
<canvas id="c"></canvas>
<script>
const canvas = document.getElementById("c");
const ctx = canvas.getContext("2d");

let angle = 0; // угол вращения крестика
let dragging = false;
let lastX = 0;

function resize() {
  canvas.width = window.innerWidth;
  canvas.height = window.innerHeight;
}
window.addEventListener("resize", resize);
resize();

const numLines = 9;   // больше линий
const spacing = 80;   // расстояние 1 секунда (80 пикселей = 1 световая секунда)
const vertLineLength = 2000; // увеличил длину линий

// drag
canvas.addEventListener("pointerdown", e => {
  dragging = true;
  lastX = e.clientX;
});
canvas.addEventListener("pointermove", e => {
  if(dragging){
    const dx = e.clientX - lastX;
    angle -= dx * 0.01;
    lastX = e.clientX;
  }
});
canvas.addEventListener("pointerup", e => dragging = false);
canvas.addEventListener("pointerleave", e => dragging = false);

function draw() {
  ctx.clearRect(0,0,canvas.width,canvas.height);

  const cx = canvas.width / 2;
  const cy = canvas.height / 2;

  const cosA = Math.cos(angle);
  const sinA = Math.sin(angle);

  // --- горизонтальная ось ---
  ctx.strokeStyle = "#888";
  ctx.lineWidth = 1; // тоньше
  ctx.beginPath();
  ctx.moveTo(0, cy);
  ctx.lineTo(canvas.width, cy);
  ctx.stroke();

  // крест ct′ + x′ (в центре)
  const ctX0 = cx - sinA*vertLineLength/2;
  const ctY0 = cy - cosA*vertLineLength/2;
  const ctX1 = cx + sinA*vertLineLength/2;
  const ctY1 = cy + cosA*vertLineLength/2;

  const xX0 = cx - cosA*vertLineLength/2;
  const xY0 = cy + sinA*vertLineLength/2;
  const xX1 = cx + cosA*vertLineLength/2;
  const xY1 = cy - sinA*vertLineLength/2;

  // ct′ (тоньше)
  ctx.strokeStyle = "#0ff";
  ctx.lineWidth = 2; // было 4
  ctx.beginPath();
  ctx.moveTo(ctX0, ctY0);
  ctx.lineTo(ctX1, ctY1);
  ctx.stroke();

  // x′ (ещё тоньше)
  ctx.strokeStyle = "#fa0";
  ctx.lineWidth = 1; // было 2
  ctx.beginPath();
  ctx.moveTo(xX0, xY0);
  ctx.lineTo(xX1, xY1);
  ctx.stroke();

  // вертикальные линии, подвешенные к x′ (1 световая секунда между ними)
  ctx.strokeStyle = "#880";
  ctx.lineWidth = 0.5; // тоньше
  for(let i=-Math.floor(numLines/2); i<=Math.floor(numLines/2); i++){
    // Позиция на оси x′ (расстояние в световых секундах)
    const seconds = i; // i световых секунд от центра
    
    // Координаты на оси x′
    const px = cx + (xX1 - cx) * (seconds / (numLines/2));
    const py = cy + (xY1 - cy) * (seconds / (numLines/2));
    
    // Направление вдоль ct′ для вертикальных линий
    const dx = ctX1 - cx;
    const dy = ctY1 - cy;
    const lineLength = vertLineLength * 1.5; // длиннее
    
    ctx.beginPath();
    ctx.moveTo(px - dx/vertLineLength*lineLength/2, py - dy/vertLineLength*lineLength/2);
    ctx.lineTo(px + dx/vertLineLength*lineLength/2, py + dy/vertLineLength*lineLength/2);
    ctx.stroke();
    
    // Разметка на линиях (засечки через каждую секунду)
    ctx.strokeStyle = "#aa0";
    ctx.lineWidth = 1;
    const numTicks = 8; // количество засечек на линии
    for(let j=-numTicks; j<=numTicks; j++){
      const tickSeconds = j; // 1 секунда между засечками
      const tickX = px + dx/vertLineLength * spacing * tickSeconds;
      const tickY = py + dy/vertLineLength * spacing * tickSeconds;
      
      // Перпендикулярное направление для засечек
      const perpX = -dy/vertLineLength * 10; // длина засечки
      const perpY = dx/vertLineLength * 10;
      
      ctx.beginPath();
      ctx.moveTo(tickX - perpX/2, tickY - perpY/2);
      ctx.lineTo(tickX + perpX/2, tickY + perpY/2);
      ctx.stroke();
    }
    ctx.strokeStyle = "#880";
  }

  // Разметка на оси ct′ (секунды)
  ctx.strokeStyle = "#0aa";
  ctx.lineWidth = 1;
  const numCTticks = 12;
  for(let i=-numCTticks; i<=numCTticks; i++){
    if(i === 0) continue; // пропускаем центр
    
    const tickX = cx + (ctX1 - cx) * (i/numCTticks);
    const tickY = cy + (ctY1 - cy) * (i/numCTticks);
    
    // Перпендикулярное направление для засечек на ct′
    const perpX = -(ctY1 - cy)/vertLineLength * 10;
    const perpY = (ctX1 - cx)/vertLineLength * 10;
    
    ctx.beginPath();
    ctx.moveTo(tickX - perpX/2, tickY - perpY/2);
    ctx.lineTo(tickX + perpX/2, tickY + perpY/2);
    ctx.stroke();
  }

  // Разметка на оси x′ (секунды)
  ctx.strokeStyle = "#a80";
  ctx.lineWidth = 1;
  for(let i=-numCTticks; i<=numCTticks; i++){
    if(i === 0) continue;
    
    const tickX = cx + (xX1 - cx) * (i/numCTticks);
    const tickY = cy + (xY1 - cy) * (i/numCTticks);
    
    // Перпендикулярное направление для засечек на x′
    const perpX = -(xY1 - cy)/vertLineLength * 10;
    const perpY = (xX1 - cx)/vertLineLength * 10;
    
    ctx.beginPath();
    ctx.moveTo(tickX - perpX/2, tickY - perpY/2);
    ctx.lineTo(tickX + perpX/2, tickY + perpY/2);
    ctx.stroke();
  }

  requestAnimationFrame(draw);
}

draw();
</script>
</body>
</html>
