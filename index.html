<!DOCTYPE html>
<html lang="ru">
<head>
<meta charset="UTF-8">
<title>СТО: крест с тонкой x′</title>
<style>
  body { margin:0; background:#111; overflow:hidden; touch-action: none; }
  canvas { display:block; }
  /* Кнопки управления */
  .controls {
    position: absolute;
    top: 10px;
    right: 10px;
    display: flex;
    gap: 8px;
    z-index: 100;
  }
  .btn {
    width: 40px;
    height: 40px;
    border-radius: 5px;
    background: rgba(0,0,0,0.7);
    border: 1px solid rgba(255,255,255,0.3);
    color: white;
    font-size: 20px;
    cursor: pointer;
    display: flex;
    align-items: center;
    justify-content: center;
    user-select: none;
  }
  .btn:hover {
    background: rgba(50,50,50,0.7);
  }
  .btn:active {
    background: rgba(100,100,100,0.7);
  }
  /* Информация о масштабе */
  .scale-info {
    position: absolute;
    bottom: 10px;
    left: 10px;
    background: rgba(0,0,0,0.7);
    color: white;
    padding: 8px 12px;
    border-radius: 5px;
    font-family: Arial, sans-serif;
    font-size: 14px;
    border: 1px solid rgba(255,255,255,0.2);
  }
</style>
<body>
<canvas id="c"></canvas>

<!-- Кнопки управления -->
<div class="controls">
  <button class="btn" id="zoomIn" title="Увеличить">+</button>
  <button class="btn" id="zoomOut" title="Уменьшить">-</button>
  <button class="btn" id="zoomReset" title="Сбросить масштаб">↻</button>
  <button class="btn" id="fullscreen" title="Полноэкранный режим">⛶</button>
</div>

<!-- Информация о масштабе -->
<div class="scale-info" id="scaleInfo">Масштаб: 0.30x</div>

<script>
const canvas = document.getElementById("c");
const ctx = canvas.getContext("2d");

let angle = 0;
let dragging = false;
let lastX = 0;
let scale = 0.3;
let offsetX = 0, offsetY = 0;

// ПАРАМЕТРЫ
const numLines = 11;           // 11 линий (по 5 с каждой стороны + центральная)
const secondsPerSide = 5;      // ±5 секунд от центра
const vertLineLength = 3000;   // общая длина линий

// РАСЧЕТ РАССТОЯНИЙ
const lineSpacing = vertLineLength / (numLines - 1);           // 1.0 сек = 300px
const halfSpacing = lineSpacing / 2;                          // 0.5 сек = 150px
const smallSpacing = lineSpacing / 10;                        // 0.1 сек = 30px

console.log(`1.0 сек = ${lineSpacing.toFixed(1)}px, 0.5 сек = ${halfSpacing.toFixed(1)}px, 0.1 сек = ${smallSpacing.toFixed(1)}px`);

// drag
canvas.addEventListener("pointerdown", e => {
  dragging = true;
  lastX = e.clientX;
});

canvas.addEventListener("pointermove", e => {
  if(dragging){
    const dx = e.clientX - lastX;
    angle -= dx * 0.01;
    lastX = e.clientX;
  }
});

canvas.addEventListener("pointerup", e => dragging = false);
canvas.addEventListener("pointerleave", e => dragging = false);

// Масштабирование колесом мыши
canvas.addEventListener("wheel", e => {
  e.preventDefault();
  const zoomFactor = 1.1;
  const rect = canvas.getBoundingClientRect();
  const mouseX = e.clientX - rect.left;
  const mouseY = e.clientY - rect.top;
  
  const worldX = (mouseX - offsetX) / scale;
  const worldY = (mouseY - offsetY) / scale;
  
  if (e.deltaY < 0) {
    scale *= zoomFactor;
  } else {
    scale /= zoomFactor;
  }
  
  scale = Math.max(0.1, Math.min(5, scale));
  
  offsetX = canvas.width/2;
  offsetY = canvas.height/2;
  
  updateScaleInfo();
});

// Кнопки масштабирования
document.getElementById('zoomIn').addEventListener('click', () => {
  scale = Math.min(5, scale * 1.2);
  updateScaleInfo();
});

document.getElementById('zoomOut').addEventListener('click', () => {
  scale = Math.max(0.1, scale / 1.2);
  updateScaleInfo();
});

document.getElementById('zoomReset').addEventListener('click', () => {
  scale = 0.3;
  offsetX = canvas.width/2;
  offsetY = canvas.height/2;
  updateScaleInfo();
});

// Полноэкранный режим
document.getElementById('fullscreen').addEventListener('click', () => {
  if (!document.fullscreenElement) {
    document.documentElement.requestFullscreen().catch(err => {
      console.error(`Ошибка полноэкранного режима: ${err.message}`);
    });
  } else {
    document.exitFullscreen();
  }
});

function updateScaleInfo() {
  document.getElementById('scaleInfo').textContent = `Масштаб: ${scale.toFixed(2)}x`;
}

function resize() {
  canvas.width = window.innerWidth;
  canvas.height = window.innerHeight;
  offsetX = canvas.width/2;
  offsetY = canvas.height/2;
}
window.addEventListener("resize", resize);
resize();

// Функция преобразования мировых координат в экранные
function toScreen(x, y) {
  return {
    x: x * scale + offsetX,
    y: y * scale + offsetY
  };
}

// Функция рисования линии
function drawLine(x1, y1, x2, y2, color, width) {
  const p1 = toScreen(x1, y1);
  const p2 = toScreen(x2, y2);
  
  ctx.strokeStyle = color;
  ctx.lineWidth = width;
  ctx.beginPath();
  ctx.moveTo(p1.x, p1.y);
  ctx.lineTo(p2.x, p2.y);
  ctx.stroke();
}

// Функция рисования отметки с разными стилями
function drawMark(px, py, dirX, dirY, length, color, width, style = "solid") {
  const p = toScreen(px, py);
  const d = toScreen(px + dirX * length/2, py + dirY * length/2);
  const d2 = toScreen(px - dirX * length/2, py - dirY * length/2);
  
  ctx.strokeStyle = color;
  ctx.lineWidth = width;
  
  if (style === "dashed") {
    ctx.setLineDash([3, 2]);
  } else {
    ctx.setLineDash([]);
  }
  
  ctx.beginPath();
  ctx.moveTo(d2.x, d2.y);
  ctx.lineTo(d.x, d.y);
  ctx.stroke();
  
  ctx.setLineDash([]); // Сбрасываем обратно
}

function draw() {
  ctx.clearRect(0,0,canvas.width,canvas.height);
  
  const cx = 0;
  const cy = 0;

  const cosA = Math.cos(angle);
  const sinA = Math.sin(angle);

  // --- горизонтальная ось ---
  drawLine(-vertLineLength, cy, vertLineLength, cy, "#888", 2);

  // крест ct′ + x′
  const ctX0 = cx - sinA*vertLineLength/2;
  const ctY0 = cy - cosA*vertLineLength/2;
  const ctX1 = cx + sinA*vertLineLength/2;
  const ctY1 = cy + cosA*vertLineLength/2;

  const xX0 = cx - cosA*vertLineLength/2;
  const xY0 = cy + sinA*vertLineLength/2;
  const xX1 = cx + cosA*vertLineLength/2;
  const xY1 = cy - sinA*vertLineLength/2;

  // ct′ (голубая)
  drawLine(ctX0, ctY0, ctX1, ctY1, "#0ff", 1);

  // x′ (оранжевая)
  drawLine(xX0, xY0, xX1, xY1, "#fa0", 1);

  // ВЕКТОРЫ ДЛЯ ОСЕЙ
  const ctDirX = ctX1 - ctX0;
  const ctDirY = ctY1 - ctY0;
  const ctLength = Math.sqrt(ctDirX*ctDirX + ctDirY*ctDirY);
  const ctUnitX = ctDirX / ctLength;
  const ctUnitY = ctDirY / ctLength;
  const ctPerpX = -ctUnitY;
  const ctPerpY = ctUnitX;
  
  const xDirX = xX1 - xX0;
  const xDirY = xY1 - xY0;
  const xLength = Math.sqrt(xDirX*xDirX + xDirY*xDirY);
  const xUnitX = xDirX / xLength;
  const xUnitY = xDirY / xLength;
  const xPerpX = -xUnitY;
  const xPerpY = xUnitX;
  
  // ОТМЕТКИ НА ГОЛУБОЙ ОСИ (ct′)
  for(let sec = 1; sec <= secondsPerSide; sec++) {
    const distance = sec * lineSpacing;
    
    // БОЛЬШИЕ ОТМЕТКИ (1.0 сек) - ТОЛСТЫЕ, ЯРКИЕ
    const bigX1 = distance * ctUnitX;
    const bigY1 = distance * ctUnitY;
    drawMark(bigX1, bigY1, ctPerpX, ctPerpY, 14, "#0ff", 1.5); // Ярко-голубые, толстые
    
    const bigX2 = -distance * ctUnitX;
    const bigY2 = -distance * ctUnitY;
    drawMark(bigX2, bigY2, ctPerpX, ctPerpY, 14, "#0ff", 1.5);
    
    // ОТМЕТКИ 0.5 сек - СРЕДНИЕ, ПУНКТИР
    const halfDistance = distance - halfSpacing;
    const halfX1 = halfDistance * ctUnitX;
    const halfY1 = halfDistance * ctUnitY;
    drawMark(halfX1, halfY1, ctPerpX, ctPerpY, 10, "#0aa", 1.0, "dashed"); // Пунктир
    
    const halfX2 = -halfDistance * ctUnitX;
    const halfY2 = -halfDistance * ctUnitY;
    drawMark(halfX2, halfY2, ctPerpX, ctPerpY, 10, "#0aa", 1.0, "dashed");
  }
  
  // МЕЛКИЕ ОТМЕТКИ (0.1 сек) НА ГОЛУБОЙ ОСИ - ТОЧКИ
  const smallMarksPerSide = secondsPerSide * 10;
  for(let tenth = 1; tenth <= smallMarksPerSide; tenth++) {
    // Пропускаем каждую 5-ю и 10-ю отметки
    if (tenth % 5 === 0 || tenth % 10 === 0) continue;
    
    const distance = tenth * smallSpacing;
    const smallX1 = distance * ctUnitX;
    const smallY1 = distance * ctUnitY;
    
    // Рисуем точку вместо линии
    const p = toScreen(smallX1, smallY1);
    ctx.fillStyle = "#099";
    ctx.beginPath();
    ctx.arc(p.x, p.y, 2, 0, Math.PI * 2);
    ctx.fill();
    
    const smallX2 = -distance * ctUnitX;
    const smallY2 = -distance * ctUnitY;
    const p2 = toScreen(smallX2, smallY2);
    ctx.beginPath();
    ctx.arc(p2.x, p2.y, 2, 0, Math.PI * 2);
    ctx.fill();
  }

  // ВЕРТИКАЛЬНЫЕ ЛИНИИ (11 штук)
  for(let i=-Math.floor(numLines/2); i<=Math.floor(numLines/2); i++){
    const t = i / Math.floor(numLines/2); 
    const px = xX0 + (xX1 - xX0)*(0.5 + t/2); 
    const py = xY0 + (xY1 - xY0)*(0.5 + t/2);
    
    // Вектор вертикальной линии
    const vertDx = -sinA;
    const vertDy = cosA;
    
    // Рисуем вертикальную линию
    drawLine(
      px - vertDx * vertLineLength/2, 
      py - vertDy * vertLineLength/2,
      px + vertDx * vertLineLength/2, 
      py + vertDy * vertLineLength/2,
      "#880", 
      1
    );
    
    // Вектор для отметок
    const markDx = cosA;
    const markDy = sinA;
    
    // ОТМЕТКИ НА ВЕРТИКАЛЬНЫХ ЛИНИЯХ
    for(let sec = 1; sec <= secondsPerSide; sec++) {
      const distance = sec * lineSpacing;
      
      // БОЛЬШИЕ ОТМЕТКИ (1.0 сек)
      const upX = px - vertDx * distance;
      const upY = py - vertDy * distance;
      drawMark(upX, upY, markDx, markDy, 12, "#fa0", 1.5); // Ярко-оранжевые
      
      const downX = px + vertDx * distance;
      const downY = py + vertDy * distance;
      drawMark(downX, downY, markDx, markDy, 12, "#fa0", 1.5);
      
      // ОТМЕТКИ 0.5 сек
      const halfDistance = distance - halfSpacing;
      const halfUpX = px - vertDx * halfDistance;
      const halfUpY = py - vertDy * halfDistance;
      drawMark(halfUpX, halfUpY, markDx, markDy, 9, "#c80", 1.0, "dashed"); // Пунктир
      
      const halfDownX = px + vertDx * halfDistance;
      const halfDownY = py + vertDy * halfDistance;
      drawMark(halfDownX, halfDownY, markDx, markDy, 9, "#c80", 1.0, "dashed");
    }
    
    // МЕЛКИЕ ОТМЕТКИ (0.1 сек) НА ВЕРТИКАЛЬНЫХ ЛИНИЯХ - ТОЧКИ
    for(let tenth = 1; tenth <= secondsPerSide * 10; tenth++) {
      if (tenth % 5 === 0 || tenth % 10 === 0) continue;
      
      const distance = tenth * smallSpacing;
      const upX = px - vertDx * distance;
      const upY = py - vertDy * distance;
      
      // Точки вместо линий
      const p = toScreen(upX, upY);
      ctx.fillStyle = "#880";
      ctx.beginPath();
      ctx.arc(p.x, p.y, 1.5, 0, Math.PI * 2);
      ctx.fill();
      
      const downX = px + vertDx * distance;
      const downY = py + vertDy * distance;
      const p2 = toScreen(downX, downY);
      ctx.beginPath();
      ctx.arc(p2.x, p2.y, 1.5, 0, Math.PI * 2);
      ctx.fill();
    }
  }

  // Центр креста
  const center = toScreen(0, 0);
  ctx.fillStyle = "#fff";
  ctx.beginPath();
  ctx.arc(center.x, center.y, 4, 0, Math.PI * 2);
  ctx.fill();

  requestAnimationFrame(draw);
}

draw();
</script>
</body>
</html>
