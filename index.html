<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>SR Hyperbolic Visualization</title>
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
<style>
  body { 
    margin:0; 
    background:#000833; 
    overflow:hidden; 
    touch-action: none; 
    font-family: Arial, sans-serif;
  }
  canvas { 
    display:block;
    position: absolute;
    top: 0;
    left: 0;
    z-index: 1;
  }
  
  .controls {
    position: fixed;
    top: 10px;
    right: 10px;
    display: flex;
    gap: 6px;
    flex-wrap: nowrap;
    justify-content: flex-end;
    max-width: 180px;
    z-index: 100;
  }
  .btn {
    width: 44px;
    height: 44px;
    border-radius: 5px;
    background: rgba(0,0,0,0.7);
    border: 1px solid rgba(255,255,255,0.3);
    color: white;
    font-size: 22px;
    cursor: pointer;
    display: flex;
    align-items: center;
    justify-content: center;
    user-select: none;
    transition: all 0.2s;
    flex-shrink: 0;
  }
  .btn:hover {
    background: rgba(50,50,50,0.9);
  }
  .btn:active {
    transform: scale(0.95);
  }
  
  .info-panel {
    position: fixed;
    top: 10px;
    left: 10px;
    background: rgba(0,0,0,0.7);
    color: white;
    padding: 0 15px;
    border-radius: 5px;
    font-size: 14px;
    border: 1px solid rgba(255,255,255,0.2);
    min-width: 200px;
    height: 44px;
    z-index: 100;
    display: flex;
    flex-direction: column;
    justify-content: center;
  }
  .info-item {
    margin: 0;
    display: flex;
    justify-content: space-between;
    align-items: center;
  }
  .info-label {
    color: #aaa;
    font-size: 11px;
  }
  .info-value {
    font-weight: bold;
    font-family: 'Courier New', monospace;
  }
  .speed-value {
    color: #fa0;
    font-size: 14px;
  }
  .rapidity-value {
    color: #0ff;
    font-size: 14px;
  }
  
  body.light-mode {
    background: #fff;
  }
  body.light-mode .btn {
    background: rgba(255,255,255,0.7);
    border: 1px solid rgba(0,0,0,0.3);
    color: #000;
  }
  body.light-mode .info-panel {
    background: rgba(255,255,255,0.9);
    color: #000;
    border: 1px solid rgba(0,0,0,0.2);
  }
  body.light-mode .info-label {
    color: #666;
  }
  
  .mode-indicator {
    position: fixed;
    top: 60px;
    right: 10px;
    background: rgba(0,0,0,0.7);
    color: white;
    padding: 5px 10px;
    border-radius: 5px;
    font-size: 12px;
    z-index: 100;
    border: 1px solid rgba(255,255,255,0.2);
  }
</style>
</head>
<body>
<canvas id="c"></canvas>

<div class="info-panel" id="infoPanel">
  <div class="info-item">
    <span class="info-label">Œ≤=v/c:</span>
    <span class="info-value speed-value" id="speedValue">0.000</span>
  </div>
  <div class="info-item">
    <span class="info-label">Rapidity œÜ:</span>
    <span class="info-value rapidity-value" id="rapidityValue">0.000</span>
  </div>
</div>

<div class="mode-indicator" id="modeIndicator">Hyperbolic</div>

<div class="controls">
  <button class="btn" id="switchMode" title="Switch mode">üîÄ</button>
  <button class="btn" id="zoomReset" title="Reset scale">‚Üª</button>
  <button class="btn" id="fullscreen" title="Fullscreen mode">‚õ∂</button>
</div>

<script>
const canvas = document.getElementById("c");
const ctx = canvas.getContext("2d");

// –ü–∞—Ä–∞–º–µ—Ç—Ä—ã –≤–∏–∑—É–∞–ª–∏–∑–∞—Ü–∏–∏
let rapidity = 0; // –±—ã—Å—Ç—Ä–æ—Ç–∞ (–≥–∏–ø–µ—Ä–±–æ–ª–∏—á–µ—Å–∫–∏–π —É–≥–æ–ª)
let dragging = false;
let lastX = 0;
let scale = 0.3;
let offsetX = 0, offsetY = 0;
let darkMode = true;
let isHyperbolic = true; // true - –≥–∏–ø–µ—Ä–±–æ–ª–∏—á–µ—Å–∫–∞—è, false - –µ–≤–∫–ª–∏–¥–æ–≤–∞

// –ü–∞—Ä–∞–º–µ—Ç—Ä—ã —Å–µ—Ç–∫–∏
const numLines = 21;
const unitsPerSide = 5; // –µ–¥–∏–Ω–∏—Ü –Ω–∞ —Å—Ç–æ—Ä–æ–Ω—É
const worldLength = 3000;

// –ú–∞–∫—Å–∏–º–∞–ª—å–Ω–∞—è –±—ã—Å—Ç—Ä–æ—Ç–∞ (—Å–æ–æ—Ç–≤–µ—Ç—Å—Ç–≤—É–µ—Ç Œ≥=1,000,000)
const TARGET_GAMMA = 1000000.000;
const MAX_RAPIDITY = Math.acosh(TARGET_GAMMA);

// –ú—É–ª—å—Ç–∏—Ç–∞—á –ø–µ—Ä–µ–º–µ–Ω–Ω—ã–µ
let touchStartDistance = null;
let touchStartAngle = null;
let touchStartCenterX = 0;
let touchStartCenterY = 0;
let touchStartScale = 0.3;
let touchStartRapidity = 0;
let touchStartOffsetX = 0;
let touchStartOffsetY = 0;
let touchStartWorldX = 0;
let touchStartWorldY = 0;

// –†–∞—Å—á–µ—Ç —Ä–∞—Å—Å—Ç–æ—è–Ω–∏–π
const unitSpacing = worldLength / (numLines - 1);
const halfSpacing = unitSpacing / 2;
const smallSpacing = unitSpacing / 10;

// –§—É–Ω–∫—Ü–∏–∏ –¥–ª—è –º—É–ª—å—Ç–∏—Ç–∞—á–∞
function getTouchDistance(touches) {
  const dx = touches[0].clientX - touches[1].clientX;
  const dy = touches[0].clientY - touches[1].clientY;
  return Math.sqrt(dx * dx + dy * dy);
}

function getTouchAngle(touches) {
  const dx = touches[0].clientX - touches[1].clientX;
  const dy = touches[0].clientY - touches[1].clientY;
  return Math.atan2(dy, dx);
}

// –û–±—Ä–∞–±–æ—Ç–∫–∞ –∫–∞—Å–∞–Ω–∏–π
canvas.addEventListener('touchstart', (e) => {
  e.preventDefault();
  
  if (e.touches.length === 2) {
    const rect = canvas.getBoundingClientRect();
    const touch1 = e.touches[0];
    const touch2 = e.touches[1];
    
    touchStartDistance = getTouchDistance(e.touches);
    touchStartAngle = getTouchAngle(e.touches);
    touchStartCenterX = (touch1.clientX + touch2.clientX) / 2 - rect.left;
    touchStartCenterY = (touch1.clientY + touch2.clientY) / 2 - rect.top;
    touchStartScale = scale;
    touchStartRapidity = rapidity;
    touchStartOffsetX = offsetX;
    touchStartOffsetY = offsetY;
    
    touchStartWorldX = (touchStartCenterX - touchStartOffsetX) / touchStartScale;
    touchStartWorldY = (touchStartCenterY - touchStartOffsetY) / touchStartScale;
    
    dragging = false;
  } else if (e.touches.length === 1) {
    dragging = true;
    lastX = e.touches[0].clientX;
  }
}, { passive: false });

canvas.addEventListener('touchmove', (e) => {
  e.preventDefault();
  
  if (e.touches.length === 2 && touchStartDistance !== null && touchStartDistance > 0) {
    const rect = canvas.getBoundingClientRect();
    const touch1 = e.touches[0];
    const touch2 = e.touches[1];
    
    const currentDistance = getTouchDistance(e.touches);
    const currentAngle = getTouchAngle(e.touches);
    const currentCenterX = (touch1.clientX + touch2.clientX) / 2 - rect.left;
    const currentCenterY = (touch1.clientY + touch2.clientY) / 2 - rect.top;
    
    // –ú–∞—Å—à—Ç–∞–±–∏—Ä–æ–≤–∞–Ω–∏–µ
    const zoomFactor = currentDistance / touchStartDistance;
    const newScale = Math.max(0.1, Math.min(5, touchStartScale * zoomFactor));
    
    // –ü–æ–≤–æ—Ä–æ—Ç/–±—ã—Å—Ç—Ä–æ—Ç–∞
    const angleDelta = currentAngle - touchStartAngle;
    let newRapidity = touchStartRapidity - angleDelta * 0.5;
    
    // –û–≥—Ä–∞–Ω–∏—á–µ–Ω–∏–µ –±—ã—Å—Ç—Ä–æ—Ç—ã
    newRapidity = Math.max(-MAX_RAPIDITY, Math.min(MAX_RAPIDITY, newRapidity));
    
    // –ü–µ—Ä–µ–º–µ—â–µ–Ω–∏–µ
    const newOffsetX = currentCenterX - touchStartWorldX * newScale;
    const newOffsetY = currentCenterY - touchStartWorldY * newScale;
    
    scale = newScale;
    rapidity = newRapidity;
    offsetX = newOffsetX;
    offsetY = newOffsetY;
    
    updateInfo();
  } else if (e.touches.length === 1 && dragging) {
    const dx = e.touches[0].clientX - lastX;
    rapidity += dx * 0.01;
    rapidity = Math.max(-MAX_RAPIDITY, Math.min(MAX_RAPIDITY, rapidity));
    lastX = e.touches[0].clientX;
    updateInfo();
  }
}, { passive: false });

canvas.addEventListener('touchend', (e) => {
  dragging = false;
  if (e.touches.length < 2) {
    touchStartDistance = null;
    touchStartAngle = null;
  }
});

// –û–±—Ä–∞–±–æ—Ç–∫–∞ –º—ã—à–∏
canvas.addEventListener("pointerdown", e => {
  dragging = true;
  lastX = e.clientX;
});

canvas.addEventListener("pointermove", e => {
  if(dragging){
    const dx = e.clientX - lastX;
    rapidity += dx * 0.01;
    rapidity = Math.max(-MAX_RAPIDITY, Math.min(MAX_RAPIDITY, rapidity));
    lastX = e.clientX;
    updateInfo();
  }
});

canvas.addEventListener("pointerup", e => dragging = false);
canvas.addEventListener("pointerleave", e => dragging = false);

// –ú–∞—Å—à—Ç–∞–±–∏—Ä–æ–≤–∞–Ω–∏–µ –∫–æ–ª–µ—Å–æ–º –º—ã—à–∏
canvas.addEventListener("wheel", e => {
  e.preventDefault();
  const zoomFactor = 1.1;
  const rect = canvas.getBoundingClientRect();
  const mouseX = e.clientX - rect.left;
  const mouseY = e.clientY - rect.top;
  
  const worldX = (mouseX - offsetX) / scale;
  const worldY = (mouseY - offsetY) / scale;
  
  if (e.deltaY < 0) {
    scale *= zoomFactor;
  } else {
    scale /= zoomFactor;
  }
  
  scale = Math.max(0.1, Math.min(5, scale));
  
  offsetX = mouseX - worldX * scale;
  offsetY = mouseY - worldY * scale;
});

// –ö–Ω–æ–ø–∫–∞ –ø–µ—Ä–µ–∫–ª—é—á–µ–Ω–∏—è —Ä–µ–∂–∏–º–∞
document.getElementById('switchMode').addEventListener('click', () => {
  isHyperbolic = !isHyperbolic;
  document.getElementById('modeIndicator').textContent = isHyperbolic ? 'Hyperbolic' : 'Euclidean';
  document.getElementById('rapidityValue').textContent = isHyperbolic ? 'œÜ' : 'Œ≥';
  updateInfo();
});

// –ö–Ω–æ–ø–∫–∞ —Å–±—Ä–æ—Å–∞ –º–∞—Å—à—Ç–∞–±–∞
document.getElementById('zoomReset').addEventListener('click', () => {
  scale = 0.3;
  offsetX = canvas.width/2;
  offsetY = canvas.height/2;
  rapidity = 0;
  updateInfo();
});

// –ü–æ–ª–Ω–æ—ç–∫—Ä–∞–Ω–Ω—ã–π —Ä–µ–∂–∏–º
document.getElementById('fullscreen').addEventListener('click', () => {
  if (!document.fullscreenElement) {
    document.documentElement.requestFullscreen();
  } else {
    document.exitFullscreen();
  }
});

// –û–±–Ω–æ–≤–ª–µ–Ω–∏–µ –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏–∏
function updateInfo() {
  const Œ≤ = Math.tanh(rapidity);
  const Œ≥ = Math.cosh(rapidity);
  
  // –§–æ—Ä–º–∞—Ç–∏—Ä—É–µ–º —Å–∫–æ—Ä–æ—Å—Ç—å
  let speedStr;
  if (Math.abs(Œ≤) < 0.0001) {
    speedStr = "0.000";
  } else if (Math.abs(rapidity) >= MAX_RAPIDITY - 0.0000001) {
    const maxŒ≤ = Math.tanh(MAX_RAPIDITY);
    speedStr = maxŒ≤.toFixed(12);
  } else {
    speedStr = Math.abs(Œ≤).toFixed(3);
  }
  if (Œ≤ < 0) speedStr = "-" + speedStr;
  
  // –§–æ—Ä–º–∞—Ç–∏—Ä—É–µ–º –±—ã—Å—Ç—Ä–æ—Ç—É –∏–ª–∏ Œ≥
  let rapidityStr;
  if (isHyperbolic) {
    if (Math.abs(rapidity) < 0.0001) {
      rapidityStr = "0.000";
    } else if (Math.abs(rapidity) >= MAX_RAPIDITY - 0.0000001) {
      rapidityStr = MAX_RAPIDITY.toFixed(3);
    } else {
      rapidityStr = Math.abs(rapidity).toFixed(3);
    }
    if (rapidity < 0) rapidityStr = "-" + rapidityStr;
  } else {
    rapidityStr = Œ≥.toFixed(3);
  }
  
  document.getElementById('speedValue').textContent = speedStr;
  document.getElementById('rapidityValue').textContent = rapidityStr;
}

function resize() {
  canvas.width = window.innerWidth;
  canvas.height = window.innerHeight;
  offsetX = canvas.width/2;
  offsetY = canvas.height/2;
}
window.addEventListener("resize", resize);
resize();

// –ü—Ä–µ–æ–±—Ä–∞–∑–æ–≤–∞–Ω–∏–µ –º–∏—Ä–æ–≤—ã—Ö –∫–æ–æ—Ä–¥–∏–Ω–∞—Ç –≤ —ç–∫—Ä–∞–Ω–Ω—ã–µ
function toScreen(x, y) {
  return {
    x: x * scale + offsetX,
    y: -y * scale + offsetY // –û–±—Ä–∞—Ç–Ω—ã–π –∑–Ω–∞–∫ Y –¥–ª—è –ø—Ä–∞–≤–∏–ª—å–Ω–æ–π –æ—Ä–∏–µ–Ω—Ç–∞—Ü–∏–∏
  };
}

// –§—É–Ω–∫—Ü–∏—è –≤—ã–±–æ—Ä–∞ —Ü–≤–µ—Ç–∞
function getColor(darkColor, lightColor) {
  return darkMode ? darkColor : lightColor;
}

// –§—É–Ω–∫—Ü–∏—è —Ä–∏—Å–æ–≤–∞–Ω–∏—è –ª–∏–Ω–∏–∏
function drawLine(x1, y1, x2, y2, darkColor, lightColor, width) {
  const p1 = toScreen(x1, y1);
  const p2 = toScreen(x2, y2);
  
  ctx.strokeStyle = getColor(darkColor, lightColor);
  ctx.lineWidth = width;
  ctx.beginPath();
  ctx.moveTo(p1.x, p1.y);
  ctx.lineTo(p2.x, p2.y);
  ctx.stroke();
}

// –§—É–Ω–∫—Ü–∏—è —Ä–∏—Å–æ–≤–∞–Ω–∏—è –æ—Ç–º–µ—Ç–∫–∏
function drawMark(px, py, dirX, dirY, length, darkColor, lightColor, width) {
  const p = toScreen(px, py);
  const d = toScreen(px + dirX * length/2, py + dirY * length/2);
  const d2 = toScreen(px - dirX * length/2, py - dirY * length/2);
  
  ctx.strokeStyle = getColor(darkColor, lightColor);
  ctx.lineWidth = width;
  ctx.beginPath();
  ctx.moveTo(d2.x, d2.y);
  ctx.lineTo(d.x, d.y);
  ctx.stroke();
}

// –§—É–Ω–∫—Ü–∏—è —Ä–∏—Å–æ–≤–∞–Ω–∏—è —Ç–µ–∫—Å—Ç–∞
function drawText(text, px, py, darkColor, lightColor, fontSize = 10, align = "center") {
  if (scale < 0.3) return;
  
  const p = toScreen(px, py);
  ctx.font = `${fontSize}px Arial`;
  ctx.fillStyle = getColor(darkColor, lightColor);
  ctx.textAlign = align;
  ctx.textBaseline = "middle";
  ctx.fillText(text, p.x, p.y);
}

// –§—É–Ω–∫—Ü–∏—è —Ä–∏—Å–æ–≤–∞–Ω–∏—è –≥–∏–ø–µ—Ä–±–æ–ª—ã (–ª–∏–Ω–∏–∏ –ø–æ—Å—Ç–æ—è–Ω–Ω–æ–≥–æ –∏–Ω—Ç–µ—Ä–≤–∞–ª–∞)
function drawHyperbola(a, darkColor, lightColor, width = 1) {
  ctx.strokeStyle = getColor(darkColor, lightColor);
  ctx.lineWidth = width;
  ctx.beginPath();
  
  // –í–µ—Ä—Ö–Ω—è—è –≤–µ—Ç–≤—å
  for(let t = -10; t <= 10; t += 0.1) {
    const x = a * Math.sinh(t);
    const y = a * Math.cosh(t);
    const p = toScreen(x, y);
    if (t === -10) {
      ctx.moveTo(p.x, p.y);
    } else {
      ctx.lineTo(p.x, p.y);
    }
  }
  
  // –ù–∏–∂–Ω—è—è –≤–µ—Ç–≤—å
  for(let t = -10; t <= 10; t += 0.1) {
    const x = a * Math.sinh(t);
    const y = -a * Math.cosh(t);
    const p = toScreen(x, y);
    if (t === -10) {
      ctx.moveTo(p.x, p.y);
    } else {
      ctx.lineTo(p.x, p.y);
    }
  }
  
  ctx.stroke();
}

function draw() {
  // –û—á–∏—Å—Ç–∫–∞
  ctx.fillStyle = darkMode ? "#000833" : "#fff";
  ctx.fillRect(0, 0, canvas.width, canvas.height);
  
  const cx = 0;
  const cy = 0;
  
  const Œ≤ = Math.tanh(rapidity);
  const Œ≥ = Math.cosh(rapidity);
  
  // --- –õ–ê–ë–û–†–ê–¢–û–†–ù–ê–Ø –°–ò–°–¢–ï–ú–ê (ct, x) ---
  
  // –ì–æ—Ä–∏–∑–æ–Ω—Ç–∞–ª—å–Ω–∞—è –æ—Å—å x (–ª–∞–±–æ—Ä–∞—Ç–æ—Ä–Ω–∞—è)
  drawLine(-worldLength, cy, worldLength, cy, "#888", "#666", 1);
  
  // –í–µ—Ä—Ç–∏–∫–∞–ª—å–Ω–∞—è –æ—Å—å ct (–ª–∞–±–æ—Ä–∞—Ç–æ—Ä–Ω–∞—è)
  drawLine(cx, -worldLength, cx, worldLength, "#888", "#666", 1);
  
  // –õ–∏–Ω–∏–∏ —Å–≤–µ—Ç–æ–≤–æ–≥–æ –∫–æ–Ω—É—Å–∞ (45¬∞)
  drawLine(-worldLength, -worldLength, worldLength, worldLength, "#f80", "#c60", 0.5);
  drawLine(-worldLength, worldLength, worldLength, -worldLength, "#f80", "#c60", 0.5);
  
  // --- –î–í–ò–ñ–£–©–ê–Ø–°–Ø –°–ò–°–¢–ï–ú–ê (ct', x') ---
  
  if (isHyperbolic) {
    // –ì–∏–ø–µ—Ä–±–æ–ª–∏—á–µ—Å–∫–∞—è –≥–µ–æ–º–µ—Ç—Ä–∏—è
    
    // –ü—Ä–µ–æ–±—Ä–∞–∑–æ–≤–∞–Ω–∏–µ –õ–æ—Ä–µ–Ω—Ü–∞:
    // ct' = Œ≥(ct - Œ≤x)
    // x' = Œ≥(x - Œ≤ct)
    
    // –û—Å—å ct' (–≥–¥–µ x' = 0): x = Œ≤ ct
    const ctPrimeSlope = Œ≤;
    const ctPrimeX1 = worldLength;
    const ctPrimeY1 = ctPrimeSlope * worldLength;
    const ctPrimeX2 = -worldLength;
    const ctPrimeY2 = ctPrimeSlope * -worldLength;
    
    // –û—Å—å x' (–≥–¥–µ ct' = 0): ct = Œ≤ x
    const xPrimeSlope = 1/Œ≤;
    const xPrimeX1 = worldLength;
    const xPrimeY1 = xPrimeSlope * worldLength;
    const xPrimeX2 = -worldLength;
    const xPrimeY2 = xPrimeSlope * -worldLength;
    
    // –†–∏—Å—É–µ–º –æ—Å–∏ –¥–≤–∏–∂—É—â–µ–π—Å—è —Å–∏—Å—Ç–µ–º—ã
    drawLine(ctPrimeX2, ctPrimeY2, ctPrimeX1, ctPrimeY1, "#0ff", "#08f", 1.5); // ct' –æ—Å—å
    drawLine(xPrimeX2, xPrimeY2, xPrimeX1, xPrimeY1, "#0f0", "#080", 1.5); // x' –æ—Å—å
    
    // –ì–∏–ø–µ—Ä–±–æ–ª—ã (–ª–∏–Ω–∏–∏ –ø–æ—Å—Ç–æ—è–Ω–Ω–æ–≥–æ –∏–Ω—Ç–µ—Ä–≤–∞–ª–∞)
    for(let i = 1; i <= 5; i++) {
      drawHyperbola(i, "#f0f", "#a0a", 0.3);
    }
    
    // –û—Ç–º–µ—Ç–∫–∏ –Ω–∞ –æ—Å–∏ ct'
    for(let t = -unitsPerSide; t <= unitsPerSide; t++) {
      if (t === 0) continue;
      
      // –í —Å–∏—Å—Ç–µ–º–µ ct' –∫–æ–æ—Ä–¥–∏–Ω–∞—Ç—ã (ct' = t, x' = 0)
      // –ü—Ä–µ–æ–±—Ä–∞–∑—É–µ–º –≤ –ª–∞–±–æ—Ä–∞—Ç–æ—Ä–Ω—ã–µ: ct = Œ≥t, x = Œ≥Œ≤t
      const ct = Œ≥ * t;
      const x = Œ≥ * Œ≤ * t;
      
      // –†–∏—Å—É–µ–º –æ—Ç–º–µ—Ç–∫—É
      const perpX = -ctPrimeSlope;
      const perpY = 1;
      const length = Math.sqrt(perpX*perpX + perpY*perpY);
      const perpUnitX = perpX / length;
      const perpUnitY = perpY / length;
      
      drawMark(x, ct, perpUnitX, perpUnitY, 10, "#0ff", "#08f", 1);
      
      // –ü–æ–¥–ø–∏—Å—å
      if (scale > 0.4) {
        drawText(t.toString(), 
                 x + perpUnitX * 12,
                 ct + perpUnitY * 12,
                 "#0ff", "#08f", 10);
      }
    }
    
    // –û—Ç–º–µ—Ç–∫–∏ –Ω–∞ –æ—Å–∏ x'
    for(let xp = -unitsPerSide; xp <= unitsPerSide; xp++) {
      if (xp === 0) continue;
      
      // –í —Å–∏—Å—Ç–µ–º–µ x' –∫–æ–æ—Ä–¥–∏–Ω–∞—Ç—ã (ct' = 0, x' = xp)
      // –ü—Ä–µ–æ–±—Ä–∞–∑—É–µ–º –≤ –ª–∞–±–æ—Ä–∞—Ç–æ—Ä–Ω—ã–µ: ct = Œ≥Œ≤xp, x = Œ≥xp
      const ct = Œ≥ * Œ≤ * xp;
      const x = Œ≥ * xp;
      
      // –†–∏—Å—É–µ–º –æ—Ç–º–µ—Ç–∫—É
      const perpX = -xPrimeSlope;
      const perpY = 1;
      const length = Math.sqrt(perpX*perpX + perpY*perpY);
      const perpUnitX = perpX / length;
      const perpUnitY = perpY / length;
      
      drawMark(x, ct, perpUnitX, perpUnitY, 10, "#0f0", "#080", 1);
      
      // –ü–æ–¥–ø–∏—Å—å
      if (scale > 0.4) {
        drawText(xp.toString(), 
                 x + perpUnitX * 12,
                 ct + perpUnitY * 12,
                 "#0f0", "#080", 10);
      }
    }
    
  } else {
    // –ï–≤–∫–ª–∏–¥–æ–≤–∞ –≥–µ–æ–º–µ—Ç—Ä–∏—è (—Å—Ç–∞—Ä–∞—è —Å—Ö–µ–º–∞)
    const angle = Math.asin(Œ≤);
    const cosA = Math.cos(angle);
    const sinA = Math.sin(angle);
    
    // –ö—Ä–µ—Å—Ç –¥–≤–∏–∂—É—â–µ–π—Å—è —Å–∏—Å—Ç–µ–º—ã
    const ctX0 = cx - sinA * worldLength/2;
    const ctY0 = cy - cosA * worldLength/2;
    const ctX1 = cx + sinA * worldLength/2;
    const ctY1 = cy + cosA * worldLength/2;

    const xX0 = cx - cosA * worldLength/2;
    const xY0 = cy + sinA * worldLength/2;
    const xX1 = cx + cosA * worldLength/2;
    const xY1 = cy - sinA * worldLength/2;

    drawLine(ctX0, ctY0, ctX1, ctY1, "#0ff", "#08f", 1.5);
    drawLine(xX0, xY0, xX1, xY1, "#0f0", "#080", 1.5);
    
    // –í–µ–∫—Ç–æ—Ä—ã –¥–ª—è –æ—Å–µ–π
    const ctDirX = ctX1 - ctX0;
    const ctDirY = ctY1 - ctY0;
    const ctLength = Math.sqrt(ctDirX*ctDirX + ctDirY*ctDirY);
    const ctUnitX = ctDirX / ctLength;
    const ctUnitY = ctDirY / ctLength;
    const ctPerpX = -ctUnitY;
    const ctPerpY = ctUnitX;
    
    // –û—Ç–º–µ—Ç–∫–∏ –Ω–∞ –≥–æ–ª—É–±–æ–π –æ—Å–∏ (ct')
    for(let sec = 1; sec <= unitsPerSide; sec++) {
      const distance = sec * unitSpacing;
      
      const bigX1 = distance * ctUnitX;
      const bigY1 = distance * ctUnitY;
      drawMark(bigX1, bigY1, ctPerpX, ctPerpY, 10, "#0ff", "#08f", 1);
      
      if (scale > 0.4) {
        drawText(sec.toString(), 
                 bigX1 - ctPerpX * 12,
                 bigY1 - ctPerpY * 12,
                 "#0ff", "#08f", 10);
      }
      
      const bigX2 = -distance * ctUnitX;
      const bigY2 = -distance * ctUnitY;
      drawMark(bigX2, bigY2, ctPerpX, ctPerpY, 10, "#0ff", "#08f", 1);
      
      if (scale > 0.4) {
        drawText((-sec).toString(), 
                 bigX2 + ctPerpX * 12,
                 bigY2 + ctPerpY * 12,
                 "#0ff", "#08f", 10);
      }
    }
  }
  
  // –°–µ—Ç–∫–∞ –ª–∞–±–æ—Ä–∞—Ç–æ—Ä–Ω–æ–π —Å–∏—Å—Ç–µ–º—ã
  for(let i = -10; i <= 10; i++) {
    // –í–µ—Ä—Ç–∏–∫–∞–ª—å–Ω—ã–µ –ª–∏–Ω–∏–∏ (–ø–æ—Å—Ç–æ—è–Ω–Ω–æ–µ x)
    if (i !== 0) {
      drawLine(i * unitSpacing, -worldLength, i * unitSpacing, worldLength, "#444", "#ccc", 0.2);
    }
    
    // –ì–æ—Ä–∏–∑–æ–Ω—Ç–∞–ª—å–Ω—ã–µ –ª–∏–Ω–∏–∏ (–ø–æ—Å—Ç–æ—è–Ω–Ω–æ–µ ct)
    if (i !== 0) {
      drawLine(-worldLength, i * unitSpacing, worldLength, i * unitSpacing, "#444", "#ccc", 0.2);
    }
  }
  
  // –ü–æ–¥–ø–∏—Å–∏ –æ—Å–µ–π
  if (scale > 0.5) {
    drawText("ct", 0, worldLength + 30, "#888", "#666", 12);
    drawText("x", worldLength + 30, 0, "#888", "#666", 12);
    
    if (isHyperbolic) {
      drawText("ct'", Œ≥ * 3, Œ≥ * Œ≤ * 3 + 15, "#0ff", "#08f", 12);
      drawText("x'", Œ≥ * 3, Œ≥ * Œ≤ * 3 - 15, "#0f0", "#080", 12);
    } else {
      const angle = Math.asin(Œ≤);
      drawText("ct'", Math.sin(angle) * 3, Math.cos(angle) * 3 + 15, "#0ff", "#08f", 12);
      drawText("x'", Math.cos(angle) * 3, -Math.sin(angle) * 3 - 15, "#0f0", "#080", 12);
    }
  }
  
  // –¶–µ–Ω—Ç—Ä (–Ω–∞—á–∞–ª–æ –∫–æ–æ—Ä–¥–∏–Ω–∞—Ç)
  const center = toScreen(0, 0);
  ctx.fillStyle = getColor("#fff", "#000");
  ctx.beginPath();
  ctx.arc(center.x, center.y, 4, 0, Math.PI * 2);
  ctx.fill();

  requestAnimationFrame(draw);
}

// –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è
updateInfo();
draw();
</script>
</body>
  </html>
