<!DOCTYPE html>
<html lang="ru">
<head>
<meta charset="UTF-8">
<title>СТО: крест с тонкой x′</title>
<style>
  body { margin:0; background:#111; overflow:hidden; touch-action: none; }
  canvas { display:block; }
  /* Кнопки управления */
  .controls {
    position: absolute;
    top: 10px;
    right: 10px;
    display: flex;
    gap: 8px;
    z-index: 100;
  }
  .btn {
    width: 40px;
    height: 40px;
    border-radius: 5px;
    background: rgba(0,0,0,0.7);
    border: 1px solid rgba(255,255,255,0.3);
    color: white;
    font-size: 20px;
    cursor: pointer;
    display: flex;
    align-items: center;
    justify-content: center;
    user-select: none;
  }
  .btn:hover {
    background: rgba(50,50,50,0.7);
  }
  .btn:active {
    background: rgba(100,100,100,0.7);
  }
  /* Информация о масштабе */
  .scale-info {
    position: absolute;
    bottom: 10px;
    left: 10px;
    background: rgba(0,0,0,0.7);
    color: white;
    padding: 8px 12px;
    border-radius: 5px;
    font-family: Arial, sans-serif;
    font-size: 14px;
    border: 1px solid rgba(255,255,255,0.2);
  }
</style>
<body>
<canvas id="c"></canvas>

<!-- Кнопки управления -->
<div class="controls">
  <button class="btn" id="zoomIn" title="Увеличить">+</button>
  <button class="btn" id="zoomOut" title="Уменьшить">-</button>
  <button class="btn" id="zoomReset" title="Сбросить масштаб">↻</button>
  <button class="btn" id="fullscreen" title="Полноэкранный режим">⛶</button>
</div>

<!-- Информация о масштабе -->
<div class="scale-info" id="scaleInfo">Масштаб: 1.00x</div>

<script>
const canvas = document.getElementById("c");
const ctx = canvas.getContext("2d");

let angle = 0;
let dragging = false;
let lastX = 0;
let scale = 0.3; // Уменьшил масштаб по умолчанию, чтобы вместить более длинные линии
let offsetX = 0, offsetY = 0;

const numLines = 7;   
const vertLineLength = 5000; // Увеличил в 5 раз: было 1000, стало 5000
const lineSpacing = vertLineLength / (numLines - 1); // 1 секунда = 833.33px
const halfSpacing = lineSpacing / 2; // 0.5 секунды = 416.67px
const smallSpacing = lineSpacing / 10; // 0.1 секунды = 83.33px

// drag
canvas.addEventListener("pointerdown", e => {
  dragging = true;
  lastX = e.clientX;
});

canvas.addEventListener("pointermove", e => {
  if(dragging){
    const dx = e.clientX - lastX;
    angle -= dx * 0.01;
    lastX = e.clientX;
  }
});

canvas.addEventListener("pointerup", e => dragging = false);
canvas.addEventListener("pointerleave", e => dragging = false);

// Масштабирование колесом мыши
canvas.addEventListener("wheel", e => {
  e.preventDefault();
  const zoomFactor = 1.1;
  const rect = canvas.getBoundingClientRect();
  const mouseX = e.clientX - rect.left;
  const mouseY = e.clientY - rect.top;
  
  const worldX = (mouseX - offsetX) / scale;
  const worldY = (mouseY - offsetY) / scale;
  
  if (e.deltaY < 0) {
    scale *= zoomFactor;
  } else {
    scale /= zoomFactor;
  }
  
  scale = Math.max(0.1, Math.min(5, scale));
  
  // Центрируем на кресте после масштабирования
  offsetX = canvas.width/2;
  offsetY = canvas.height/2;
  
  updateScaleInfo();
});

// Кнопки масштабирования
document.getElementById('zoomIn').addEventListener('click', () => {
  scale = Math.min(5, scale * 1.2);
  updateScaleInfo();
});

document.getElementById('zoomOut').addEventListener('click', () => {
  scale = Math.max(0.1, scale / 1.2);
  updateScaleInfo();
});

document.getElementById('zoomReset').addEventListener('click', () => {
  scale = 0.3; // Возвращаем к уменьшенному масштабу по умолчанию
  offsetX = canvas.width/2;
  offsetY = canvas.height/2;
  updateScaleInfo();
});

// Полноэкранный режим
document.getElementById('fullscreen').addEventListener('click', () => {
  if (!document.fullscreenElement) {
    document.documentElement.requestFullscreen().catch(err => {
      console.error(`Ошибка полноэкранного режима: ${err.message}`);
    });
  } else {
    document.exitFullscreen();
  }
});

function updateScaleInfo() {
  document.getElementById('scaleInfo').textContent = `Масштаб: ${scale.toFixed(2)}x`;
}

function resize() {
  canvas.width = window.innerWidth;
  canvas.height = window.innerHeight;
  offsetX = canvas.width/2;
  offsetY = canvas.height/2;
}
window.addEventListener("resize", resize);
resize();

// Функция преобразования мировых координат в экранные
function toScreen(x, y) {
  return {
    x: x * scale + offsetX,
    y: y * scale + offsetY
  };
}

// Функция рисования линии
function drawLine(x1, y1, x2, y2, color, width) {
  const p1 = toScreen(x1, y1);
  const p2 = toScreen(x2, y2);
  
  ctx.strokeStyle = color;
  ctx.lineWidth = width;
  ctx.beginPath();
  ctx.moveTo(p1.x, p1.y);
  ctx.lineTo(p2.x, p2.y);
  ctx.stroke();
}

// Функция рисования отметки
function drawMark(px, py, dirX, dirY, length, color, width) {
  const p = toScreen(px, py);
  const d = toScreen(px + dirX * length/2, py + dirY * length/2);
  const d2 = toScreen(px - dirX * length/2, py - dirY * length/2);
  
  ctx.strokeStyle = color;
  ctx.lineWidth = width;
  ctx.beginPath();
  ctx.moveTo(d2.x, d2.y);
  ctx.lineTo(d.x, d.y);
  ctx.stroke();
}

function draw() {
  ctx.clearRect(0,0,canvas.width,canvas.height);
  
  const cx = 0;
  const cy = 0;

  const cosA = Math.cos(angle);
  const sinA = Math.sin(angle);

  // --- горизонтальная ось ---
  drawLine(-vertLineLength, cy, vertLineLength, cy, "#888", 2);

  // крест ct′ + x′
  const ctX0 = cx - sinA*vertLineLength/2;
  const ctY0 = cy - cosA*vertLineLength/2;
  const ctX1 = cx + sinA*vertLineLength/2;
  const ctY1 = cy + cosA*vertLineLength/2;

  const xX0 = cx - cosA*vertLineLength/2;
  const xY0 = cy + sinA*vertLineLength/2;
  const xX1 = cx + cosA*vertLineLength/2;
  const xY1 = cy - sinA*vertLineLength/2;

  // ct′ (голубая)
  drawLine(ctX0, ctY0, ctX1, ctY1, "#0ff", 1);

  // x′ (оранжевая)
  drawLine(xX0, xY0, xX1, xY1, "#fa0", 1);

  // ВЫЧИСЛЯЕМ ВЕКТОРЫ ДЛЯ ОСЕЙ
  // Вектор направления голубой оси (ct′)
  const ctDirX = ctX1 - ctX0;
  const ctDirY = ctY1 - ctY0;
  const ctLength = Math.sqrt(ctDirX*ctDirX + ctDirY*ctDirY);
  const ctUnitX = ctDirX / ctLength;
  const ctUnitY = ctDirY / ctLength;
  const ctPerpX = -ctUnitY;
  const ctPerpY = ctUnitX;
  
  // Вектор направления оранжевой оси (x′)
  const xDirX = xX1 - xX0;
  const xDirY = xY1 - xY0;
  const xLength = Math.sqrt(xDirX*xDirX + xDirY*xDirY);
  const xUnitX = xDirX / xLength;
  const xUnitY = xDirY / xLength;
  const xPerpX = -xUnitY;
  const xPerpY = xUnitX;
  
  // КОЛИЧЕСТВО ОТМЕТОК НА ОСЯХ (в одну сторону)
  const marksPerSide = Math.floor(vertLineLength / 2 / lineSpacing);
  
  // ОТМЕТКИ НА ГОЛУБОЙ ОСИ (ct′)
  for(let j = 1; j <= marksPerSide; j++) {
    const distance = j * lineSpacing;
    
    // Большие отметки (1 секунда)
    const markX1 = distance * ctUnitX;
    const markY1 = distance * ctUnitY;
    drawMark(markX1, markY1, ctPerpX, ctPerpY, 12, "#0aa", 0.8);
    
    const markX2 = -distance * ctUnitX;
    const markY2 = -distance * ctUnitY;
    drawMark(markX2, markY2, ctPerpX, ctPerpY, 12, "#0aa", 0.8);
    
    // Отметки 0.5 секунды (средние)
    const halfDistance = distance - halfSpacing;
    if (halfDistance > 0) {
      const halfX1 = halfDistance * ctUnitX;
      const halfY1 = halfDistance * ctUnitY;
      drawMark(halfX1, halfY1, ctPerpX, ctPerpY, 9, "#099", 0.6);
      
      const halfX2 = -halfDistance * ctUnitX;
      const halfY2 = -halfDistance * ctUnitY;
      drawMark(halfX2, halfY2, ctPerpX, ctPerpY, 9, "#099", 0.6);
    }
  }
  
  // МЕЛКИЕ ОТМЕТКИ (0.1 секунды) НА ГОЛУБОЙ ОСИ - БОЛЕЕ ЗАМЕТНЫЕ
  const smallMarksPerSide = Math.floor(vertLineLength / 2 / smallSpacing);
  for(let j = 1; j <= smallMarksPerSide; j++) {
    // Пропускаем каждую 5-ю отметку (там отметка 0.5) и каждую 10-ю (там отметка 1.0)
    if (j % 5 === 0 || j % 10 === 0) continue;
    
    const distance = j * smallSpacing;
    const smallX1 = distance * ctUnitX;
    const smallY1 = distance * ctUnitY;
    drawMark(smallX1, smallY1, ctPerpX, ctPerpY, 7, "#077", 0.5); // Увеличил длину и толщину
    
    const smallX2 = -distance * ctUnitX;
    const smallY2 = -distance * ctUnitY;
    drawMark(smallX2, smallY2, ctPerpX, ctPerpY, 7, "#077", 0.5);
  }

  // ВЕРТИКАЛЬНЫЕ ЛИНИИ
  for(let i=-Math.floor(numLines/2); i<=Math.floor(numLines/2); i++){
    const t = i / Math.floor(numLines/2); 
    const px = xX0 + (xX1 - xX0)*(0.5 + t/2); 
    const py = xY0 + (xY1 - xY0)*(0.5 + t/2);
    
    // Вектор вертикальной линии (перпендикулярно x′)
    const vertDx = -sinA;
    const vertDy = cosA;
    
    // Рисуем вертикальную линию
    drawLine(
      px - vertDx * vertLineLength/2, 
      py - vertDy * vertLineLength/2,
      px + vertDx * vertLineLength/2, 
      py + vertDy * vertLineLength/2,
      "#880", 
      1
    );
    
    // Вектор для отметок (параллельно x′)
    const markDx = cosA;
    const markDy = sinA;
    
    // ОТМЕТКИ НА ВЕРТИКАЛЬНЫХ ЛИНИЯХ
    for(let j = 1; j <= marksPerSide; j++) {
      const distance = j * lineSpacing;
      
      // Большие отметки (1 секунда)
      const upX = px - vertDx * distance;
      const upY = py - vertDy * distance;
      drawMark(upX, upY, markDx, markDy, 10, "#aa0", 0.8);
      
      const downX = px + vertDx * distance;
      const downY = py + vertDy * distance;
      drawMark(downX, downY, markDx, markDy, 10, "#aa0", 0.8);
      
      // Отметки 0.5 секунды (средние)
      const halfDistance = distance - halfSpacing;
      if (halfDistance > 0) {
        const halfUpX = px - vertDx * halfDistance;
        const halfUpY = py - vertDy * halfDistance;
        drawMark(halfUpX, halfUpY, markDx, markDy, 8, "#990", 0.6);
        
        const halfDownX = px + vertDx * halfDistance;
        const halfDownY = py + vertDy * halfDistance;
        drawMark(halfDownX, halfDownY, markDx, markDy, 8, "#990", 0.6);
      }
    }
    
    // МЕЛКИЕ ОТМЕТКИ (0.1 секунды) НА ВЕРТИКАЛЬНЫХ ЛИНИЯХ - БОЛЕЕ ЗАМЕТНЫЕ
    for(let j = 1; j <= smallMarksPerSide; j++) {
      // Пропускаем каждую 5-ю отметку (там отметка 0.5) и каждую 10-ю (там отметка 1.0)
      if (j % 5 === 0 || j % 10 === 0) continue;
      
      const distance = j * smallSpacing;
      const upX = px - vertDx * distance;
      const upY = py - vertDy * distance;
      drawMark(upX, upY, markDx, markDy, 6, "#770", 0.5); // Увеличил длину и толщину
      
      const downX = px + vertDx * distance;
      const downY = py + vertDy * distance;
      drawMark(downX, downY, markDx, markDy, 6, "#770", 0.5);
    }
  }

  // Центр креста
  const center = toScreen(0, 0);
  ctx.fillStyle = "#fff";
  ctx.beginPath();
  ctx.arc(center.x, center.y, 3, 0, Math.PI * 2);
  ctx.fill();

  requestAnimationFrame(draw);
}

draw();
</script>
</body>
</html>
