<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>SR Visualization - Multi Geometry</title>
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
<style>
body { 
  margin:0; 
  background:#000833; 
  overflow:hidden; 
  touch-action: none; 
  font-family: Arial, sans-serif;
}
canvas { 
  display:block;
  position: absolute;
  top: 0;
  left: 0;
  z-index: 1;
}
.controls {
  position: fixed;
  top: 10px;
  right: 10px;
  display: flex;
  gap: 6px;
  flex-wrap: nowrap;
  justify-content: flex-end;
  max-width: 300px;
  z-index: 100;
}
.btn {
  width: 44px;
  height: 44px;
  border-radius: 5px;
  background: rgba(0,0,0,0.7);
  border: 1px solid rgba(255,255,255,0.3);
  color: white;
  font-size: 22px;
  cursor: pointer;
  display: flex;
  align-items: center;
  justify-content: center;
  user-select: none;
  transition: all 0.2s;
  flex-shrink: 0;
}
.btn:hover {
  background: rgba(50,50,50,0.9);
}
.btn:active {
  transform: scale(0.95);
}
.info-panel {
  position: fixed;
  top: 10px;
  left: 10px;
  background: rgba(0,0,0,0.7);
  color: white;
  padding: 0 15px;
  border-radius: 5px;
  font-size: 14px;
  border: 1px solid rgba(255,255,255,0.2);
  min-width: 200px;
  height: 44px;
  z-index: 100;
  display: flex;
  flex-direction: column;
  justify-content: center;
}
.info-item { display: flex; justify-content: space-between; align-items: center; }
.info-label { color: #aaa; font-size: 11px; }
.info-value { font-weight: bold; font-family: 'Courier New', monospace; }
.speed-value { color: #fa0; font-size: 14px; }
.gamma-value { color: #0ff; font-size: 14px; }
body.light-mode { background: #fff; }
body.light-mode .btn { background: rgba(255,255,255,0.7); border: 1px solid rgba(0,0,0,0.3); color: #000; }
body.light-mode .info-panel { background: rgba(255,255,255,0.9); color: #000; border: 1px solid rgba(0,0,0,0.2); }
body.light-mode .info-label { color: #666; }
</style>
</head>
<body>
<canvas id="c"></canvas>

<div class="info-panel" id="infoPanel">
  <div class="info-item">
    <span class="info-label">Speed:</span>
    <span class="info-value speed-value" id="speedValue">0.000c</span>
  </div>
  <div class="info-item">
    <span class="info-label">Î³:</span>
    <span class="info-value gamma-value" id="gammaValue">1.000</span>
  </div>
</div>

<div class="controls">
  <button class="btn" id="euclidBtn" title="Euclidean">E</button>
  <button class="btn" id="minkBtn" title="Minkowski">M</button>
  <button class="btn" id="sphereBtn" title="Spherical / Poincare">S</button>
  <button class="btn" id="negBtn" title="Negative/Invert">â˜€</button>
  <button class="btn" id="zoomReset" title="Reset scale">â†»</button>
  <button class="btn" id="fullscreen" title="Fullscreen mode">â›¶</button>
</div>

<script>
const canvas = document.getElementById("c");
const ctx = canvas.getContext("2d");
let angle = 0;
let dragging = false;
let lastX = 0;
let scale = 0.3;
let offsetX = 0, offsetY = 0;
let darkMode = true;
let currentGeometry = "euclid"; // euclid, minkowski, sphere

const numLines = 21;
const secondsPerSide = 10;
const vertLineLength = 3000;
const TARGET_GAMMA = 1000000.0;
const TARGET_V = Math.sqrt(1 - 1/(TARGET_GAMMA*TARGET_GAMMA));
const MAX_ANGLE = Math.asin(TARGET_V);

let touchStartDistance = null;
let touchStartAngle = null;
let touchStartCenterX = 0;
let touchStartCenterY = 0;
let touchStartScale = 0.3;
let touchStartAngleSystem = 0;
let touchStartOffsetX = 0;
let touchStartOffsetY = 0;
let touchStartWorldX = 0;
let touchStartWorldY = 0;

const lineSpacing = vertLineLength / (numLines - 1);
const halfSpacing = lineSpacing / 2;
const smallSpacing = lineSpacing / 10;

function getTouchDistance(touches){ const dx = touches[0].clientX - touches[1].clientX; const dy = touches[0].clientY - touches[1].clientY; return Math.sqrt(dx*dx+dy*dy);}
function getTouchAngle(touches){ const dx = touches[0].clientX - touches[1].clientX; const dy = touches[0].clientY - touches[1].clientY; return Math.atan2(dy,dx);}

canvas.addEventListener('touchstart', (e) => {
  e.preventDefault();
  if(e.touches.length===2){
    const rect = canvas.getBoundingClientRect();
    const touch1 = e.touches[0], touch2 = e.touches[1];
    touchStartDistance = getTouchDistance(e.touches);
    touchStartAngle = getTouchAngle(e.touches);
    touchStartCenterX = (touch1.clientX+touch2.clientX)/2 - rect.left;
    touchStartCenterY = (touch1.clientY+touch2.clientY)/2 - rect.top;
    touchStartScale = scale;
    touchStartAngleSystem = angle;
    touchStartOffsetX = offsetX;
    touchStartOffsetY = offsetY;
    touchStartWorldX = (touchStartCenterX - touchStartOffsetX)/touchStartScale;
    touchStartWorldY = (touchStartCenterY - touchStartOffsetY)/touchStartScale;
    dragging = false;
  } else if(e.touches.length===1){ dragging=true; lastX=e.touches[0].clientX; }
},{passive:false});

canvas.addEventListener('touchmove',(e)=>{
  e.preventDefault();
  if(e.touches.length===2 && touchStartDistance!==null && touchStartDistance>0){
    const rect = canvas.getBoundingClientRect();
    const touch1 = e.touches[0], touch2 = e.touches[1];
    const currentDistance = getTouchDistance(e.touches);
    const currentAngle = getTouchAngle(e.touches);
    const currentCenterX = (touch1.clientX + touch2.clientX)/2 - rect.left;
    const currentCenterY = (touch1.clientY + touch2.clientY)/2 - rect.top;
    const zoomFactor = currentDistance/touchStartDistance;
    const newScale = Math.max(0.1,Math.min(5,touchStartScale*zoomFactor));
    const angleDelta = currentAngle-touchStartAngle;
    let newAngle = touchStartAngleSystem - angleDelta*0.8;
    newAngle = Math.max(-MAX_ANGLE,Math.min(MAX_ANGLE,newAngle));
    const newOffsetX = currentCenterX - touchStartWorldX*newScale;
    const newOffsetY = currentCenterY - touchStartWorldY*newScale;
    scale=newScale; angle=newAngle; offsetX=newOffsetX; offsetY=newOffsetY;
    updateInfo();
  } else if(e.touches.length===1 && dragging){
    const dx=e.touches[0].clientX-lastX;
    angle+=dx*0.01;
    angle=Math.max(-MAX_ANGLE,Math.min(MAX_ANGLE,angle));
    lastX=e.touches[0].clientX;
    updateInfo();
  }
},{passive:false});

canvas.addEventListener("pointerdown", e=>{dragging=true; lastX=e.clientX;});
canvas.addEventListener("pointermove", e=>{if(dragging){const dx=e.clientX-lastX; angle+=dx*0.01; angle=Math.max(-MAX_ANGLE,Math.min(MAX_ANGLE,angle)); lastX=e.clientX; updateInfo();}});
canvas.addEventListener("pointerup", e=>dragging=false);
canvas.addEventListener("pointerleave", e=>dragging=false);
canvas.addEventListener("wheel", e=>{
  e.preventDefault();
  const zoomFactor=1.1;
  const rect=canvas.getBoundingClientRect();
  const mouseX=e.clientX-rect.left;
  const mouseY=e.clientY-rect.top;
  const worldX=(mouseX-offsetX)/scale;
  const worldY=(mouseY-offsetY)/scale;
  if(e.deltaY<0){ scale*=zoomFactor;} else {scale/=zoomFactor;}
  scale=Math.max(0.1,Math.min(5,scale));
  offsetX=mouseX-worldX*scale;
  offsetY=mouseY-worldY*scale;
});

document.getElementById('negBtn').addEventListener('click',()=>{
  darkMode=!darkMode;
  document.body.classList.toggle('light-mode',!darkMode);
  document.getElementById('negBtn').textContent=darkMode?'â˜€':'ðŸŒ™';
});
document.getElementById('zoomReset').addEventListener('click',()=>{scale=0.3; offsetX=canvas.width/2; offsetY=canvas.height/2;});
document.getElementById('fullscreen').addEventListener('click',()=>{
  if(!document.fullscreenElement){ document.documentElement.requestFullscreen().catch(err=>{console.error(`Fullscreen error: ${err.message}`);});
  } else {document.exitFullscreen();}
});

// ÐŸÐ•Ð Ð•ÐšÐ›Ð®Ð§Ð•ÐÐ˜Ð• Ð“Ð•ÐžÐœÐ•Ð¢Ð Ð˜Ð™
document.getElementById('euclidBtn').addEventListener('click',()=>{currentGeometry="euclid"; scale=0.3; offsetX=canvas.width/2; offsetY=canvas.height/2;});
document.getElementById('minkBtn').addEventListener('click',()=>{currentGeometry="minkowski"; scale=0.3; offsetX=canvas.width/2; offsetY=canvas.height/2;});
document.getElementById('sphereBtn').addEventListener('click',()=>{currentGeometry="sphere"; scale=0.3; offsetX=canvas.width/2; offsetY=canvas.height/2;});

function updateInfo(){
  let velocity=Math.sin(angle);
  let velocityStr;
  if(Math.abs(velocity)<0.0001){velocityStr="0.000c";} else {
    const absV=Math.abs(velocity);
    if(Math.abs(Math.abs(angle)-MAX_ANGLE)<0.0000001){velocityStr=TARGET_V.toFixed(12)+"c";}
    else if(absV>0.999999){velocityStr=absV.toFixed(12)+"c";}
    else if(absV>0.999){velocityStr=absV.toFixed(9)+"c";}
    else if(absV>0.99){velocityStr=absV.toFixed(6)+"c";}
    else {velocityStr=absV.toFixed(3)+"c";}
    if(velocity<0) velocityStr="-"+velocityStr;
  }
  let gamma=1; const v=Math.abs(velocity);
  if(v<0.999999999999){gamma=1/Math.sqrt(1-v*v);} else {gamma=TARGET_GAMMA;}
  let gammaStr;
  if(Math.abs(Math.abs(angle)-MAX_ANGLE)<0.0000001){gammaStr=TARGET_GAMMA.toFixed(3);}
  else if(gamma>=1000){gammaStr=gamma.toFixed(3);}
  else{gammaStr=gamma.toFixed(3);}
  document.getElementById('speedValue').textContent=velocityStr;
  document.getElementById('gammaValue').textContent=gammaStr;
  const speedValue=document.getElementById('speedValue');
  const absV=Math.abs(velocity);
  if(absV<0.3){speedValue.style.color=darkMode?'#0f0':'#080';}
  else if(absV<0.7){speedValue.style.color=darkMode?'#ff0':'#880';}
  else if(absV<0.95){speedValue.style.color=darkMode?'#f80':'#c60';}
  else{speedValue.style.color=darkMode?'#f00':'#c00';}
}

function resize(){canvas.width=window.innerWidth; canvas.height=window.innerHeight; offsetX=canvas.width/2; offsetY=canvas.height/2;}
window.addEventListener("resize", resize); resize();

function toScreen(x,y){return{x:x*scale+offsetX,y:y*scale+offsetY};}
function getColor(darkColor,lightColor){return darkMode?darkColor:lightColor;}
function drawLine(x1,y1,x2,y2,darkColor,lightColor,width){
  const p1=toScreen(x1,y1); const p2=toScreen(x2,y2);
  ctx.strokeStyle=getColor(darkColor,lightColor); ctx.lineWidth=width; ctx.beginPath(); ctx.moveTo(p1.x,p1.y); ctx.lineTo(p2.x,p2.y); ctx.stroke();
}
function drawPoint(px,py,radius,darkColor,lightColor){
  const p=toScreen(px,py); ctx.fillStyle=getColor(darkColor,lightColor); ctx.beginPath(); ctx.arc(p.x,p.y,radius,0,Math.PI*2); ctx.fill();
}
function drawMark(px,py,dirX,dirY,length,darkColor,lightColor,width,style="solid"){
  const p=toScreen(px,py); const d=toScreen(px+dirX*length/2,py+dirY*length/2);
  const d2=toScreen(px-dirX*length/2,py-dirY*length/2); ctx.strokeStyle=getColor(darkColor,lightColor); ctx.lineWidth=width;
  if(style==="dashed"){ctx.setLineDash([3,2]);}else{ctx.setLineDash([]);}
  ctx.beginPath(); ctx.moveTo(d2.x,d2.y); ctx.lineTo(d.x,d.y); ctx.stroke(); ctx.setLineDash([]);
}
function drawText(text,px,py,darkColor,lightColor,fontSize=10,align="center"){if(scale<0.5) return; const p=toScreen(px,py); ctx.font=`${fontSize}px Arial`; ctx.fillStyle=getColor(darkColor,lightColor); ctx.textAlign=align; ctx.textBaseline="middle"; ctx.fillText(text,p.x,p.y);}

// --- ÐžÐ¡ÐÐžÐ’ÐÐÐ¯ Ð¤Ð£ÐÐšÐ¦Ð˜Ð¯ ---
function draw(){
  if(darkMode){ctx.fillStyle="#000833";}else{ctx.fillStyle="#fff";}
  ctx.fillRect(0,0,canvas.width,canvas.height);
  
  if(currentGeometry==="euclid"){drawEuclid();}
  else if(currentGeometry==="minkowski"){drawMinkowski();}
  else if(currentGeometry==="sphere"){drawSphere();}
  
  requestAnimationFrame(draw);
}

// --- Ð­Ð²ÐºÐ»Ð¸Ð´Ð¾Ð²Ð° Ð´Ð¸Ð°Ð³Ñ€Ð°Ð¼Ð¼Ð° (Ñ‚Ð²Ð¾Ñ Ð¾Ñ€Ð¸Ð³Ð¸Ð½Ð°Ð»ÑŒÐ½Ð°Ñ) ---
function drawEuclid(){
  const cx=0, cy=0;
  const cosA=Math.cos(angle), sinA=Math.sin(angle);
  drawLine(-vertLineLength,cy,vertLineLength,cy,"#0ff","#08f",1);
  const ctX0=cx-sinA*vertLineLength/2, ctY0=cy-cosA*vertLineLength/2;
  const ctX1=cx+sinA*vertLineLength/2, ctY1=cy+cosA*vertLineLength/2;
  const xX0=cx-cosA*vertLineLength/2, xY0=cy+sinA*vertLineLength/2;
  const xX1=cx+cosA*vertLineLength/2, xY1=cy-sinA*vertLineLength/2;
  drawLine(ctX0,ctY0,ctX1,ctY1,"#0ff","#08f",1);
  drawLine(xX0,xY0,xX1,xY1,"#888","#666",1);
  // Ð»Ð¸Ð½Ð¸Ð¸ Ð¸ Ð¾Ñ‚Ð¼ÐµÑ‚ÐºÐ¸ ÐºÐ°Ðº Ð² Ð¾Ñ€Ð¸Ð³Ð¸Ð½Ð°Ð»Ðµ
  for(let i=-10;i<=10;i++){ const px=i*lineSpacing; drawLine(px,-vertLineLength/2,px,vertLineLength/2,"#888","#666",1);}
  const center=toScreen(0,0); ctx.fillStyle=getColor("#fff","#000"); ctx.beginPath(); ctx.arc(center.x,center.y,4,0,Math.PI*2); ctx.fill();
}

// --- ÐœÐ¸Ð½ÐºÐ¾Ð²ÑÐºÐ¾Ð³Ð¾ (Ð¾Ð±Ñ‹Ñ‡Ð½Ð°Ñ Ñ€ÐµÐ»ÑÑ‚Ð¸Ð²Ð¸ÑÑ‚ÑÐºÐ°Ñ) ---
function drawMinkowski(){
  const cx=0, cy=0; drawLine(-vertLineLength,0,vertLineLength,0,"#0ff","#08f",1);
  // ÐºÑ€ÐµÑÑ‚: Ð½Ð°ÐºÐ»Ð¾Ð½ Ð¾ÑÐ¸ Ð²Ñ€ÐµÐ¼ÐµÐ½Ð¸ Ð¸ Ð¿Ñ€Ð¾ÑÑ‚Ñ€Ð°Ð½ÑÑ‚Ð²Ð°
  const cosA=Math.cos(angle), sinA=Math.sin(angle);
  const ctX0=cx-sinA*vertLineLength/2, ctY0=cy-cosA*vertLineLength/2;
  const ctX1=cx+sinA*vertLineLength/2, ctY1=cy+cosA
  
