<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>SR Visualization</title>
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
<style>
  body { 
    margin:0; 
    background:#000833; 
    overflow:hidden; 
    touch-action: none; 
    font-family: Arial, sans-serif;
  }
  canvas { 
    display:block;
    position: absolute;
    top: 0;
    left: 0;
    z-index: 1;
  }
  
  /* –ö–Ω–æ–ø–∫–∏ —É–ø—Ä–∞–≤–ª–µ–Ω–∏—è –≤ —Ä—è–¥ */
  .controls {
    position: fixed;
    top: 10px;
    right: 10px;
    display: flex;
    gap: 6px;
    flex-wrap: nowrap;
    justify-content: flex-end;
    max-width: 240px; /* –Ω–µ–º–Ω–æ–≥–æ —Ä–∞—Å—à–∏—Ä–µ–Ω–æ –ø–æ–¥ –Ω–æ–≤—É—é –∫–Ω–æ–ø–∫—É */
    z-index: 100;
  }
  .btn {
    width: 44px;
    height: 44px;
    border-radius: 5px;
    background: rgba(0,0,0,0.7);
    border: 1px solid rgba(255,255,255,0.3);
    color: white;
    font-size: 22px;
    cursor: pointer;
    display: flex;
    align-items: center;
    justify-content: center;
    user-select: none;
    transition: all 0.2s;
    flex-shrink: 0;
  }
  .btn:hover {
    background: rgba(50,50,50,0.9);
  }
  .btn:active {
    transform: scale(0.95);
  }
  
  /* –ü–∞–Ω–µ–ª—å –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏–∏ - –ø–æ–¥–æ–≥–Ω–∞–Ω–∞ –ø–æ –≤—ã—Å–æ—Ç–µ –ø–æ–¥ –∫–Ω–æ–ø–∫–∏ */
  .info-panel {
    position: fixed;
    top: 10px;
    left: 10px;
    background: rgba(0,0,0,0.7);
    color: white;
    padding: 0 15px;
    border-radius: 5px;
    font-size: 14px;
    border: 1px solid rgba(255,255,255,0.2);
    min-width: 200px;
    height: 44px;
    z-index: 100;
    display: flex;
    flex-direction: column;
    justify-content: center;
  }
  .info-item {
    margin: 0;
    display: flex;
    justify-content: space-between;
    align-items: center;
  }
  .info-label {
    color: #aaa;
    font-size: 11px;
  }
  .info-value {
    font-weight: bold;
    font-family: 'Courier New', monospace;
  }
  .speed-value {
    color: #fa0;
    font-size: 14px;
  }
  .gamma-value {
    color: #0ff;
    font-size: 14px;
  }
  
  /* –°—Ç–∏–ª–∏ –¥–ª—è —Å–≤–µ—Ç–ª–æ–≥–æ —Ä–µ–∂–∏–º–∞ */
  body.light-mode {
    background: #fff;
  }
  body.light-mode .btn {
    background: rgba(255,255,255,0.7);
    border: 1px solid rgba(0,0,0,0.3);
    color: #000;
  }
  body.light-mode .info-panel {
    background: rgba(255,255,255,0.9);
    color: #000;
    border: 1px solid rgba(0,0,0,0.2);
  }
  body.light-mode .info-label {
    color: #666;
  }
</style>
</head>
<body>
<canvas id="c"></canvas>

<!-- –ü–∞–Ω–µ–ª—å –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏–∏ -->
<div class="info-panel" id="infoPanel">
  <div class="info-item">
    <span class="info-label">Speed:</span>
    <span class="info-value speed-value" id="speedValue">0.000c</span>
  </div>
  <div class="info-item">
    <span class="info-label">Œ≥:</span>
    <span class="info-value gamma-value" id="gammaValue">1.000</span>
  </div>
</div>

<!-- –ö–Ω–æ–ø–∫–∏ —É–ø—Ä–∞–≤–ª–µ–Ω–∏—è -->
<div class="controls">
  <button class="btn" id="geometryBtn" title="Hyperbolic geometry">‚Ñç</button>
  <button class="btn" id="negBtn" title="Negative/Invert">‚òÄ</button>
  <button class="btn" id="zoomReset" title="Reset scale">‚Üª</button>
  <button class="btn" id="fullscreen" title="Fullscreen mode">‚õ∂</button>
</div>

<script>
const canvas = document.getElementById("c");
const ctx = canvas.getContext("2d");

// –ü–∞—Ä–∞–º–µ—Ç—Ä—ã –≤–∏–∑—É–∞–ª–∏–∑–∞—Ü–∏–∏
let angle = 0; // —É–≥–æ–ª –ø–æ–≤–æ—Ä–æ—Ç–∞ –∫—Ä–µ—Å—Ç–∞
let dragging = false;
let lastX = 0;
let scale = 0.3;
let offsetX = 0, offsetY = 0;
let darkMode = true;

// –ü–ê–†–ê–ú–ï–¢–†–´ (—É–≤–µ–ª–∏—á–µ–Ω–Ω—ã–µ)
const numLines = 21; // 10 —Å –∫–∞–∂–¥–æ–π —Å—Ç–æ—Ä–æ–Ω—ã + —Ü–µ–Ω—Ç—Ä–∞–ª—å–Ω–∞—è = 21
const secondsPerSide = 10; // –±—ã–ª–æ 5, —Ç–µ–ø–µ—Ä—å 10
const vertLineLength = 3000;

// –¢ARGET GAMMA = 1,000,000
const TARGET_GAMMA = 1000000.000;
// –í—ã—á–∏—Å–ª—è–µ–º —Å–∫–æ—Ä–æ—Å—Ç—å –¥–ª—è Œ≥ = 1,000,000
const TARGET_V = Math.sqrt(1 - 1/(TARGET_GAMMA * TARGET_GAMMA));
// –í—ã—á–∏—Å–ª—è–µ–º —É–≥–æ–ª –¥–ª—è —ç—Ç–æ–π —Å–∫–æ—Ä–æ—Å—Ç–∏ (v/c = sin(angle))
const MAX_ANGLE = Math.asin(TARGET_V);

// –ú–£–õ–¨–¢–ò–¢–ê–ß –ü–ï–†–ï–ú–ï–ù–ù–´–ï –¥–ª—è —É–º–Ω–æ–≥–æ –∂–µ—Å—Ç–∞
let touchStartDistance = null;
let touchStartAngle = null;
let touchStartCenterX = 0;
let touchStartCenterY = 0;
let touchStartScale = 0.3;
let touchStartAngleSystem = 0;
let touchStartOffsetX = 0;
let touchStartOffsetY = 0;
let touchStartWorldX = 0;
let touchStartWorldY = 0;

// –†–ê–°–ß–ï–¢ –†–ê–°–°–¢–û–Ø–ù–ò–ô
const lineSpacing = vertLineLength / (numLines - 1);
const halfSpacing = lineSpacing / 2;
const smallSpacing = lineSpacing / 10;

// –§—É–Ω–∫—Ü–∏—è –¥–ª—è –≤—ã—á–∏—Å–ª–µ–Ω–∏—è —Ä–∞—Å—Å—Ç–æ—è–Ω–∏—è –º–µ–∂–¥—É –¥–≤—É–º—è —Ç–æ—á–∫–∞–º–∏ –∫–∞—Å–∞–Ω–∏—è
function getTouchDistance(touches) {
  const dx = touches[0].clientX - touches[1].clientX;
  const dy = touches[0].clientY - touches[1].clientY;
  return Math.sqrt(dx * dx + dy * dy);
}

// –§—É–Ω–∫—Ü–∏—è –¥–ª—è –≤—ã—á–∏—Å–ª–µ–Ω–∏—è —É–≥–ª–∞ –º–µ–∂–¥—É –¥–≤—É–º—è —Ç–æ—á–∫–∞–º–∏ –∫–∞—Å–∞–Ω–∏—è
function getTouchAngle(touches) {
  const dx = touches[0].clientX - touches[1].clientX;
  const dy = touches[0].clientY - touches[1].clientY;
  return Math.atan2(dy, dx);
}

// –û–ë–†–ê–ë–û–¢–ö–ê –ö–ê–°–ê–ù–ò–ô (—É–º–Ω—ã–π –º—É–ª—å—Ç–∏—Ç–∞—á)
canvas.addEventListener('touchstart', (e) => {
  e.preventDefault();
  
  if (e.touches.length === 2) {
    // –ù–∞—á–∞–ª–æ –∂–µ—Å—Ç–∞ –¥–≤—É–º—è –ø–∞–ª—å—Ü–∞–º–∏ - –∑–∞–ø–æ–º–∏–Ω–∞–µ–º –í–°–ï –ø–∞—Ä–∞–º–µ—Ç—Ä—ã
    const rect = canvas.getBoundingClientRect();
    const touch1 = e.touches[0];
    const touch2 = e.touches[1];
    
    touchStartDistance = getTouchDistance(e.touches);
    touchStartAngle = getTouchAngle(e.touches);
    touchStartCenterX = (touch1.clientX + touch2.clientX) / 2 - rect.left;
    touchStartCenterY = (touch1.clientY + touch2.clientY) / 2 - rect.top;
    touchStartScale = scale;
    touchStartAngleSystem = angle;
    touchStartOffsetX = offsetX;
    touchStartOffsetY = offsetY;
    
    // –í—ã—á–∏—Å–ª—è–µ–º –º–∏—Ä–æ–≤—ã–µ –∫–æ–æ—Ä–¥–∏–Ω–∞—Ç—ã —Ü–µ–Ω—Ç—Ä–∞ –∂–µ—Å—Ç–∞
    touchStartWorldX = (touchStartCenterX - touchStartOffsetX) / touchStartScale;
    touchStartWorldY = (touchStartCenterY - touchStartOffsetY) / touchStartScale;
    
    dragging = false; // –û—Ç–∫–ª—é—á–∞–µ–º –æ–±—ã—á–Ω–æ–µ –ø–µ—Ä–µ—Ç–∞—Å–∫–∏–≤–∞–Ω–∏–µ
  } else if (e.touches.length === 1) {
    // –ù–∞—á–∞–ª–æ –ø–µ—Ä–µ—Ç–∞—Å–∫–∏–≤–∞–Ω–∏—è –æ–¥–Ω–∏–º –ø–∞–ª—å—Ü–µ–º
    dragging = true;
    lastX = e.touches[0].clientX;
  }
}, { passive: false });

canvas.addEventListener('touchmove', (e) => {
  e.preventDefault();
  
  if (e.touches.length === 2 && touchStartDistance !== null && touchStartDistance > 0) {
    // –û–±—Ä–∞–±–æ—Ç–∫–∞ —É–º–Ω–æ–≥–æ –∂–µ—Å—Ç–∞ –¥–≤—É–º—è –ø–∞–ª—å—Ü–∞–º–∏: –ó–£–ú + –ü–û–í–û–†–û–¢ + –ü–ï–†–ï–ú–ï–©–ï–ù–ò–ï
    const rect = canvas.getBoundingClientRect();
    const touch1 = e.touches[0];
    const touch2 = e.touches[1];
    
    const currentDistance = getTouchDistance(e.touches);
    const currentAngle = getTouchAngle(e.touches);
    const currentCenterX = (touch1.clientX + touch2.clientX) / 2 - rect.left;
    const currentCenterY = (touch1.clientY + touch2.clientY) / 2 - rect.top;
    
    // 1. –ú–ê–°–®–¢–ê–ë–ò–†–û–í–ê–ù–ò–ï (–∑—É–º)
    const zoomFactor = currentDistance / touchStartDistance;
    const newScale = Math.max(0.1, Math.min(5, touchStartScale * zoomFactor));
    
    // 2. –ü–û–í–û–†–û–¢ –°–ò–°–¢–ï–ú–´ (—Ä–µ–≤–µ—Ä—Å –¥–ª—è –∏–Ω—Ç—É–∏—Ç–∏–≤–Ω–æ—Å—Ç–∏)
    const angleDelta = currentAngle - touchStartAngle;
    let newAngle = touchStartAngleSystem - angleDelta * 0.8; // –†–µ–≤–µ—Ä—Å
    
    // –û–≥—Ä–∞–Ω–∏—á–µ–Ω–∏–µ —É–≥–ª–∞
    newAngle = Math.max(-MAX_ANGLE, Math.min(MAX_ANGLE, newAngle));
    
    // 3. –ü–ï–†–ï–ú–ï–©–ï–ù–ò–ï (–ø–∞–Ω–æ—Ä–∞–º–∏—Ä–æ–≤–∞–Ω–∏–µ) —Å —É—á—ë—Ç–æ–º –∑—É–º–∞
    // –í—ã—á–∏—Å–ª—è–µ–º –Ω–æ–≤—ã–µ offset —Ç–∞–∫, —á—Ç–æ–±—ã —Ç–æ—á–∫–∞ –ø–æ–¥ –Ω–∞—á–∞–ª—å–Ω—ã–º —Ü–µ–Ω—Ç—Ä–æ–º –∂–µ—Å—Ç–∞
    // –æ—Å—Ç–∞–≤–∞–ª–∞—Å—å –ø–æ–¥ —Ç–µ–∫—É—â–∏–º —Ü–µ–Ω—Ç—Ä–æ–º –∂–µ—Å—Ç–∞
    const newOffsetX = currentCenterX - touchStartWorldX * newScale;
    const newOffsetY = currentCenterY - touchStartWorldY * newScale;
    
    // –ü—Ä–∏–º–µ–Ω—è–µ–º –≤—Å–µ –∏–∑–º–µ–Ω–µ–Ω–∏—è
    scale = newScale;
    angle = newAngle;
    offsetX = newOffsetX;
    offsetY = newOffsetY;
    
    updateInfo();
  } else if (e.touches.length === 1 && dragging) {
    // –ü–µ—Ä–µ—Ç–∞—Å–∫–∏–≤–∞–Ω–∏–µ –æ–¥–Ω–∏–º –ø–∞–ª—å—Ü–µ–º - –¢–û–õ–¨–ö–û –ü–û–í–û–†–û–¢
    const dx = e.touches[0].clientX - lastX;
    // –†–ï–í–ï–†–°: –º–µ–Ω—è–µ–º –∑–Ω–∞–∫ –Ω–∞ –ø—Ä–æ—Ç–∏–≤–æ–ø–æ–ª–æ–∂–Ω—ã–π
    angle += dx * 0.01;
    
    // –û–≥—Ä–∞–Ω–∏—á–µ–Ω–∏–µ —É–≥–ª–∞
    angle = Math.max(-MAX_ANGLE, Math.min(MAX_ANGLE, angle));
    
    lastX = e.touches[0].clientX;
    updateInfo();
  }
}, { passive: false });

canvas.addEventListener('touchend', (e) => {
  dragging = false;
  if (e.touches.length < 2) {
    touchStartDistance = null;
    touchStartAngle = null;
  }
});

// –û–ë–†–ê–ë–û–¢–ö–ê –ú–´–®–ò
canvas.addEventListener("pointerdown", e => {
  dragging = true;
  lastX = e.clientX;
});

canvas.addEventListener("pointermove", e => {
  if(dragging){
    const dx = e.clientX - lastX;
    // –†–ï–í–ï–†–°: –º–µ–Ω—è–µ–º –∑–Ω–∞–∫ –Ω–∞ –ø—Ä–æ—Ç–∏–≤–æ–ø–æ–ª–æ–∂–Ω—ã–π
    angle += dx * 0.01;
    
    // –û–≥—Ä–∞–Ω–∏—á–µ–Ω–∏–µ —É–≥–ª–∞
    angle = Math.max(-MAX_ANGLE, Math.min(MAX_ANGLE, angle));
    
    lastX = e.clientX;
    updateInfo();
  }
});

canvas.addEventListener("pointerup", e => dragging = false);
canvas.addEventListener("pointerleave", e => dragging = false);

// –ú–∞—Å—à—Ç–∞–±–∏—Ä–æ–≤–∞–Ω–∏–µ –∫–æ–ª–µ—Å–æ–º –º—ã—à–∏
canvas.addEventListener("wheel", e => {
  e.preventDefault();
  const zoomFactor = 1.1;
  const rect = canvas.getBoundingClientRect();
  const mouseX = e.clientX - rect.left;
  const mouseY = e.clientY - rect.top;
  
  const worldX = (mouseX - offsetX) / scale;
  const worldY = (mouseY - offsetY) / scale;
  
  if (e.deltaY < 0) {
    scale *= zoomFactor;
  } else {
    scale /= zoomFactor;
  }
  
  scale = Math.max(0.1, Math.min(5, scale));
  
  offsetX = mouseX - worldX * scale;
  offsetY = mouseY - worldY * scale;
});

// –ö–Ω–æ–ø–∫–∞ –Ω–µ–≥–∞—Ç–∏–≤–∞/—Å–≤–µ—Ç–ª–æ–≥–æ —Ä–µ–∂–∏–º–∞
document.getElementById('negBtn').addEventListener('click', () => {
  darkMode = !darkMode;
  document.body.classList.toggle('light-mode', !darkMode);
  document.getElementById('negBtn').textContent = darkMode ? '‚òÄ' : 'üåô';
});

// –ö–Ω–æ–ø–∫–∞ —Å–±—Ä–æ—Å–∞ –º–∞—Å—à—Ç–∞–±–∞
document.getElementById('zoomReset').addEventListener('click', () => {
  scale = 0.3;
  offsetX = canvas.width/2;
  offsetY = canvas.height/2;
});

// –ü–æ–ª–Ω–æ—ç–∫—Ä–∞–Ω–Ω—ã–π —Ä–µ–∂–∏–º
document.getElementById('fullscreen').addEventListener('click', () => {
  if (!document.fullscreenElement) {
    document.documentElement.requestFullscreen().catch(err => {
      console.error(`Fullscreen error: ${err.message}`);
    });
  } else {
    document.exitFullscreen();
  }
});

// === –ù–û–í–ê–Ø –ö–ù–û–ü–ö–ê: –ì–ò–ü–ï–†–ë–û–õ–ò–ß–ï–°–ö–ê–Ø –ì–ï–û–ú–ï–¢–†–ò–Ø ===
document.getElementById('geometryBtn').addEventListener('click', () => {
  const hyperbolicHTML = `<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Hyperbolic SR Visualization</title>
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
<style>
  body { margin:0; background:#000833; overflow:hidden; touch-action: none; font-family: Arial, sans-serif; }
  canvas { display:block; position: absolute; top: 0; left: 0; z-index: 1; }
  .controls {
    position: fixed; top: 10px; right: 10px; display: flex; gap: 6px; flex-wrap: nowrap; max-width: 180px; z-index: 100;
  }
  .btn {
    width: 44px; height: 44px; border-radius: 5px; background: rgba(0,0,0,0.7);
    border: 1px solid rgba(255,255,255,0.3); color: white; font-size: 22px; cursor: pointer;
    display: flex; align-items: center; justify-content: center; user-select: none; transition: all 0.2s; flex-shrink: 0;
  }
  .btn:hover { background: rgba(50,50,50,0.9); }
  .btn:active { transform: scale(0.95); }
  .info-panel {
    position: fixed; top: 10px; left: 10px; background: rgba(0,0,0,0.7); color: white; padding: 0 15px;
    border-radius: 5px; font-size: 14px; border: 1px solid rgba(255,255,255,0.2); min-width: 200px; height: 44px; z-index: 100;
    display: flex; flex-direction: column; justify-content: center;
  }
  .info-item { margin: 0; display: flex; justify-content: space-between; align-items: center; }
  .info-label { color: #aaa; font-size: 11px; }
  .info-value { font-weight: bold; font-family: 'Courier New', monospace; }
  .speed-value { color: #fa0; font-size: 14px; }
  .gamma-value { color: #0ff; font-size: 14px; }
  body.light-mode { background: #fff; }
  body.light-mode .btn { background: rgba(255,255,255,0.7); border: 1px solid rgba(0,0,0,0.3); color: #000; }
  body.light-mode .info-panel { background: rgba(255,255,255,0.9); color: #000; border: 1px solid rgba(0,0,0,0.2); }
  body.light-mode .info-label { color: #666; }
</style>
</head>
<body>
<canvas id="c"></canvas>

<div class="info-panel" id="infoPanel">
  <div class="info-item">
    <span class="info-label">Speed:</span>
    <span class="info-value speed-value" id="speedValue">0.000c</span>
  </div>
  <div class="info-item">
    <span class="info-label">Œ≥:</span>
    <span class="info-value gamma-value" id="gammaValue">1.000</span>
  </div>
</div>

<div class="controls">
  <button class="btn" id="negBtn" title="Negative/Invert">‚òÄ</button>
  <button class="btn" id="zoomReset" title="Reset scale">‚Üª</button>
  <button class="btn" id="fullscreen" title="Fullscreen mode">‚õ∂</button>
</div>

<script>
const canvas = document.getElementById("c");
const ctx = canvas.getContext("2d");

let rapidity = 0;
let dragging = false;
let lastX = 0;
let scale = 0.4;
let offsetX = 0, offsetY = 0;
let darkMode = true;

const MAX_RAPIDITY = 12;
const RANGE = 8;
const worldlineSteps = [0.5, 1, 2, 3, 5, 8];
const simultaneitySteps = [0.5, 1, 2, 3, 5, 8];

function toScreen(x, y) {
  return { x: x * scale + offsetX, y: y * scale + offsetY };
}
function getColor(dark, light) { return darkMode ? dark : light; }
function drawLine(x1, y1, x2, y2, dark, light, width = 1) {
  const p1 = toScreen(x1, y1), p2 = toScreen(x2, y2);
  ctx.strokeStyle = getColor(dark, light);
  ctx.lineWidth = width;
  ctx.beginPath(); ctx.moveTo(p1.x, p1.y); ctx.lineTo(p2.x, p2.y); ctx.stroke();
}
function drawPoint(x, y, r, dark, light) {
  const p = toScreen(x, y);
  ctx.fillStyle = getColor(dark, light);
  ctx.beginPath(); ctx.arc(p.x, p.y, r, 0, Math.PI*2); ctx.fill();
}
function drawHyperbola(points, dark, light) {
  if (points.length < 2) return;
  ctx.strokeStyle = getColor(dark, light);
  ctx.beginPath();
  const p0 = toScreen(points[0].x, points[0].t);
  ctx.moveTo(p0.x, p0.y);
  for (let i = 1; i < points.length; i++) {
    const p = toScreen(points[i].x, points[i].t);
    ctx.lineTo(p.x, p.y);
  }
  ctx.stroke();
}

canvas.addEventListener("pointerdown", e => { dragging = true; lastX = e.clientX; });
canvas.addEventListener("pointermove", e => {
  if(dragging){
    const dx = e.clientX - lastX;
    rapidity += dx * 0.02;
    rapidity = Math.max(-MAX_RAPIDITY, Math.min(MAX_RAPIDITY, rapidity));
    lastX = e.clientX;
    updateInfo();
  }
});
canvas.addEventListener("pointerup", () => dragging = false);
canvas.addEventListener("pointerleave", () => dragging = false);

canvas.addEventListener("wheel", e => {
  e.preventDefault();
  const zoomFactor = 1.1;
  const rect = canvas.getBoundingClientRect();
  const mouseX = e.clientX - rect.left;
  const mouseY = e.clientY - rect.top;
  const worldX = (mouseX - offsetX) / scale;
  const worldY = (mouseY - offsetY) / scale;
  scale *= e.deltaY < 0 ? zoomFactor : 1/zoomFactor;
  scale = Math.max(0.05, Math.min(5, scale));
  offsetX = mouseX - worldX * scale;
  offsetY = mouseY - worldY * scale;
});

canvas.addEventListener('touchstart', e => {
  if (e.touches.length === 1) { dragging = true; lastX = e.touches[0].clientX; }
  e.preventDefault();
}, { passive: false });
canvas.addEventListener('touchmove', e => {
  if (e.touches.length === 1 && dragging) {
    const dx = e.touches[0].clientX - lastX;
    rapidity += dx * 0.02;
    rapidity = Math.max(-MAX_RAPIDITY, Math.min(MAX_RAPIDITY, rapidity));
    lastX = e.touches[0].clientX;
    updateInfo();
  }
  e.preventDefault();
}, { passive: false });
canvas.addEventListener('touchend', () => dragging = false);

document.getElementById('negBtn').addEventListener('click', () => {
  darkMode = !darkMode;
  document.body.classList.toggle('light-mode', !darkMode);
  document.getElementById('negBtn').textContent = darkMode ? '‚òÄ' : 'üåô';
});
document.getElementById('zoomReset').addEventListener('click', () => {
  scale = 0.4;
  offsetX = canvas.width/2;
  offsetY = canvas.height/2;
});
document.getElementById('fullscreen').addEventListener('click', () => {
  if (!document.fullscreenElement) document.documentElement.requestFullscreen().catch(err => {});
  else document.exitFullscreen();
});

function draw() {
  ctx.fillStyle = darkMode ? "#000833" : "#fff";
  ctx.fillRect(0, 0, canvas.width, canvas.height);

  // –ú–∏—Ä–æ–≤—ã–µ –ª–∏–Ω–∏–∏ (t¬≤ - x¬≤ = œÑ¬≤)
  for (const tau of worldlineSteps) {
    const ptsF = [], ptsP = [];
    for (let x = -RANGE; x <= RANGE; x += 0.03) {
      const t = Math.sqrt(tau*tau + x*x);
      ptsF.push({x, t}); ptsP.push({x, -t});
    }
    drawHyperbola(ptsF, "#0c0", "#080");
    drawHyperbola(ptsP, "#0c0", "#080");
  }

  // –õ–∏–Ω–∏–∏ –æ–¥–Ω–æ–≤—Ä–µ–º–µ–Ω–Ω–æ—Å—Ç–∏ (x¬≤ - t¬≤ = Œæ¬≤)
  for (const xi of simultaneitySteps) {
    const ptsR = [], ptsL = [];
    for (let t = -RANGE; t <= RANGE; t += 0.03) {
      const x = Math.sqrt(xi*xi + t*t);
      ptsR.push({x, t}); ptsL.push({-x, t});
    }
    drawHyperbola(ptsR, "#88f", "#66d");
    drawHyperbola(ptsL, "#88f", "#66d");
  }

  // –°–≤–µ—Ç–æ–≤—ã–µ –∫–æ–Ω—É—Å—ã
  drawLine(-RANGE, -RANGE, RANGE, RANGE, "#ff8", "#cc6");
  drawLine(-RANGE, RANGE, RANGE, -RANGE, "#ff8", "#cc6");

  // –û—Å–∏ –ª–∞–±–æ—Ä–∞—Ç–æ—Ä–Ω–æ–π —Å–∏—Å—Ç–µ–º—ã
  drawLine(-RANGE, 0, RANGE, 0, "#fff", "#000", 1.5);
  drawLine(0, -RANGE, 0, RANGE, "#fff", "#000", 1.5);

  // –î–≤–∏–∂—É—â–∞—è—Å—è —Å–∏—Å—Ç–µ–º–∞
  const v = Math.tanh(rapidity);
  drawLine(-RANGE, -v*RANGE, RANGE, v*RANGE, "#ff0", "#c80", 2); // x'
  drawLine(-v*RANGE, -RANGE, v*RANGE, RANGE, "#0ff", "#0aa", 2); // t'

  drawPoint(0, 0, 4, "#fff", "#000");

  requestAnimationFrame(draw);
}

function updateInfo() {
  const v = Math.tanh(rapidity);
  const gamma = Math.cosh(rapidity);

  let vStr = "0.000c";
  if (Math.abs(v) > 0.0001) {
    if (Math.abs(v) > 0.999999999999) vStr = "1.000c";
    else vStr = (Math.abs(v).toFixed(12).replace(/0+$/, '') + "c");
    if (v < 0) vStr = "-" + vStr;
  }
  document.getElementById('speedValue').textContent = vStr;

  let gStr = gamma.toFixed(3);
  if (gamma > 10000) gStr = gamma.toExponential(3);
  document.getElementById('gammaValue').textContent = gStr;

  const el = document.getElementById('speedValue');
  const av = Math.abs(v);
  if (av < 0.3) el.style.color = darkMode ? '#0f0' : '#080';
  else if (av < 0.7) el.style.color = darkMode ? '#ff0' : '#880';
  else if (av < 0.95) el.style.color = darkMode ? '#f80' : '#c60';
  else el.style.color = darkMode ? '#f00' : '#c00';
}

function resize() {
  canvas.width = window.innerWidth;
  canvas.height = window.innerHeight;
  offsetX = canvas.width/2;
  offsetY = canvas.height/2;
}
window.addEventListener("resize", resize);
resize();
updateInfo();
draw();
</script>
</body>
</html>`;

  const w = window.open('', '_blank', 'width=1200,height=800,menubar=no,toolbar=no');
  w.document.write(hyperbolicHTML);
  w.document.close();
});

// –û–±–Ω–æ–≤–ª–µ–Ω–∏–µ –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏–∏
function updateInfo() {
  // v/c = sin(angle) –¥–ª—è –ø—Ä–æ—Å—Ç–æ–π –≤–∏–∑—É–∞–ª–∏–∑–∞—Ü–∏–∏
  const velocity = Math.sin(angle);
  
  // –§–æ—Ä–º–∞—Ç–∏—Ä—É–µ–º —Å–∫–æ—Ä–æ—Å—Ç—å
  let velocityStr;
  if (Math.abs(velocity) < 0.0001) {
    velocityStr = "0.000c";
  } else {
    // –ü—Ä–∏ –º–∞–∫—Å–∏–º–∞–ª—å–Ω–æ–º —É–≥–ª–µ –∏—Å–ø–æ–ª—å–∑—É–µ–º –≤—ã—á–∏—Å–ª–µ–Ω–Ω—É—é —Å–∫–æ—Ä–æ—Å—Ç—å –¥–ª—è Œ≥=1,000,000
    const absV = Math.abs(velocity);
    if (Math.abs(Math.abs(angle) - MAX_ANGLE) < 0.0000001) {
      // –ü—Ä–∏ –º–∞–∫—Å–∏–º–∞–ª—å–Ω–æ–º —É–≥–ª–µ –ø–æ–∫–∞–∑—ã–≤–∞–µ–º —Ç–æ—á–Ω–æ–µ –∑–Ω–∞—á–µ–Ω–∏–µ
      velocityStr = TARGET_V.toFixed(12) + "c";
    } else if (absV > 0.999999) {
      velocityStr = absV.toFixed(12) + "c";
    } else if (absV > 0.999) {
      velocityStr = absV.toFixed(9) + "c";
    } else if (absV > 0.99) {
      velocityStr = absV.toFixed(6) + "c";
    } else {
      velocityStr = absV.toFixed(3) + "c";
    }
    if (velocity < 0) velocityStr = "-" + velocityStr;
  }
  
  // –í—ã—á–∏—Å–ª—è–µ–º Œ≥
  let gamma = 1;
  const v = Math.abs(velocity);
  if (v < 0.999999999999) {
    gamma = 1 / Math.sqrt(1 - v * v);
  } else {
    gamma = TARGET_GAMMA; // –ú–∞–∫—Å–∏–º–∞–ª—å–Ω–æ–µ –∑–Ω–∞—á–µ–Ω–∏–µ
  }
  
  // –§–æ—Ä–º–∞—Ç–∏—Ä—É–µ–º Œ≥
  let gammaStr;
  if (Math.abs(Math.abs(angle) - MAX_ANGLE) < 0.0000001) {
    // –ü—Ä–∏ –º–∞–∫—Å–∏–º–∞–ª—å–Ω–æ–º —É–≥–ª–µ –ø–æ–∫–∞–∑—ã–≤–∞–µ–º —Ç–æ—á–Ω–æ–µ –∑–Ω–∞—á–µ–Ω–∏–µ
    gammaStr = TARGET_GAMMA.toFixed(3);
  } else if (gamma >= 1000) {
    gammaStr = gamma.toFixed(3);
  } else {
    gammaStr = gamma.toFixed(3);
  }
  
  document.getElementById('
