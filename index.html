<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>SR Visualization</title>
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
<style>
  body { 
    margin:0; 
    background:#000833; 
    overflow:hidden; 
    touch-action: none; 
    font-family: Arial, sans-serif;
  }
  canvas { 
    display:block;
    position: absolute;
    top: 0;
    left: 0;
    z-index: 1;
  }
  .controls {
    position: fixed;
    top: 8px; /* –ù–µ–º–Ω–æ–≥–æ –ø–æ–¥–Ω—è–ª–∏ */
    right: 8px; /* –ù–µ–º–Ω–æ–≥–æ –±–ª–∏–∂–µ –∫ –∫—Ä–∞—é */
    display: flex;
    gap: 4px; /* –£–º–µ–Ω—å—à–∏–ª–∏ –ø—Ä–æ–º–µ–∂—É—Ç–æ–∫ */
    flex-wrap: nowrap;
    justify-content: flex-end;
    max-width: 150px; /* –£–º–µ–Ω—å—à–∏–ª–∏ –º–∞–∫—Å–∏–º–∞–ª—å–Ω—É—é —à–∏—Ä–∏–Ω—É */
    z-index: 100;
  }
  .btn {
    width: 35px; /* –ë—ã–ª–æ 44px, —É–º–µ–Ω—å—à–∏–ª–∏ –Ω–∞ 20% */
    height: 35px; /* –ë—ã–ª–æ 44px, —É–º–µ–Ω—å—à–∏–ª–∏ –Ω–∞ 20% */
    border-radius: 5px;
    background: rgba(0,0,0,0.7);
    border: 1px solid rgba(255,255,255,0.3);
    color: white;
    font-size: 18px; /* –£–º–µ–Ω—å—à–∏–ª–∏ —à—Ä–∏—Ñ—Ç –ø—Ä–æ–ø–æ—Ä—Ü–∏–æ–Ω–∞–ª—å–Ω–æ */
    cursor: pointer;
    display: flex;
    align-items: center;
    justify-content: center;
    user-select: none;
    transition: all 0.2s;
    flex-shrink: 0;
  }
  .btn:hover {
    background: rgba(50,50,50,0.9);
  }
  .btn:active {
    transform: scale(0.95);
  }
  .info-panel {
    position: fixed;
    top: 8px; /* –ù–µ–º–Ω–æ–≥–æ –ø–æ–¥–Ω—è–ª–∏ */
    left: 8px; /* –ù–µ–º–Ω–æ–≥–æ –±–ª–∏–∂–µ –∫ –∫—Ä–∞—é */
    background: rgba(0,0,0,0.7);
    color: white;
    padding: 0 8px; /* –£–º–µ–Ω—å—à–∏–ª–∏ –≥–æ—Ä–∏–∑–æ–Ω—Ç–∞–ª—å–Ω—ã–µ –æ—Ç—Å—Ç—É–ø—ã */
    border-radius: 5px;
    font-size: 11px; /* –£–º–µ–Ω—å—à–∏–ª–∏ –±–∞–∑–æ–≤—ã–π —à—Ä–∏—Ñ—Ç */
    border: 1px solid rgba(255,255,255,0.2);
    min-width: 110px; /* –§–∏–∫—Å–∏—Ä–æ–≤–∞–Ω–Ω–∞—è –º–∏–Ω–∏–º–∞–ª—å–Ω–∞—è —à–∏—Ä–∏–Ω–∞ */
    max-width: 110px; /* –§–∏–∫—Å–∏—Ä–æ–≤–∞–Ω–Ω–∞—è –º–∞–∫—Å–∏–º–∞–ª—å–Ω–∞—è —à–∏—Ä–∏–Ω–∞ */
    width: 110px; /* –§–∏–∫—Å–∏—Ä–æ–≤–∞–Ω–Ω–∞—è —à–∏—Ä–∏–Ω–∞ */
    height: 35px; /* –ë—ã–ª–æ 44px, —É–º–µ–Ω—å—à–∏–ª–∏ –Ω–∞ 20% */
    z-index: 100;
    display: flex;
    flex-direction: column;
    justify-content: center;
    box-sizing: border-box; /* –ß—Ç–æ–±—ã padding —É—á–∏—Ç—ã–≤–∞–ª—Å—è –≤ —à–∏—Ä–∏–Ω–µ */
  }
  .info-item {
    margin: 0;
    display: flex;
    justify-content: space-between;
    align-items: center;
    min-width: 0; /* –ü–æ–∑–≤–æ–ª—è–µ—Ç —Å–∂–∏–º–∞—Ç—å—Å—è */
  }
  .info-label {
    color: #aaa;
    font-size: 9px; /* –£–º–µ–Ω—å—à–∏–ª–∏ */
    white-space: nowrap;
    flex-shrink: 0; /* –ù–µ —Å–∂–∏–º–∞–µ—Ç—Å—è */
  }
  .info-value {
    font-weight: bold;
    font-family: 'Courier New', monospace;
    white-space: nowrap;
    min-width: 0; /* –ü–æ–∑–≤–æ–ª—è–µ—Ç —Å–∂–∏–º–∞—Ç—å—Å—è */
    overflow: hidden;
    text-overflow: ellipsis; /* –û–±—Ä–µ–∑–∞–µ–º —Ç–µ–∫—Å—Ç –µ—Å–ª–∏ –Ω–µ –ø–æ–º–µ—â–∞–µ—Ç—Å—è */
    flex-shrink: 1; /* –ú–æ–∂–µ—Ç —Å–∂–∏–º–∞—Ç—å—Å—è */
  }
  .speed-value {
    color: #fa0;
    font-size: 10px; /* –ë—ã–ª–æ 14px, —É–º–µ–Ω—å—à–∏–ª–∏ */
  }
  .gamma-value {
    color: #0ff;
    font-size: 10px; /* –ë—ã–ª–æ 14px, —É–º–µ–Ω—å—à–∏–ª–∏ */
  }
  body.light-mode {
    background: #fff;
  }
  body.light-mode .btn {
    background: rgba(255,255,255,0.7);
    border: 1px solid rgba(0,0,0,0.3);
    color: #000;
  }
  body.light-mode .info-panel {
    background: rgba(255,255,255,0.9);
    color: #000;
    border: 1px solid rgba(0,0,0,0.2);
  }
  body.light-mode .info-label {
    color: #666;
  }
</style>
</head>
<body>
<canvas id="c"></canvas>

<div class="info-panel" id="infoPanel">
  <div class="info-item">
    <span class="info-label">Speed:</span>
    <span class="info-value speed-value" id="speedValue">0.000c</span>
  </div>
  <div class="info-item">
    <span class="info-label">Œ≥:</span>
    <span class="info-value gamma-value" id="gammaValue">1.000</span>
  </div>
</div>

<div class="controls">
  <button class="btn" id="modeBtn" title="Toggle Diagram">M</button>
  <button class="btn" id="negBtn" title="Negative/Invert">‚òÄ</button>
  <button class="btn" id="zoomReset" title="Reset scale">‚Üª</button>
  <button class="btn" id="fullscreen" title="Fullscreen mode">‚õ∂</button>
</div>

<script>
const canvas = document.getElementById("c");
const ctx = canvas.getContext("2d");

// –ü–∞—Ä–∞–º–µ—Ç—Ä—ã –≤–∏–∑—É–∞–ª–∏–∑–∞—Ü–∏–∏
let angle = 0;
let dragging = false;
let lastX = 0;
let scale = 0.3;
let offsetX = 0, offsetY = 0;
let darkMode = true;
let showMinkowski = false;

// –ü–ê–†–ê–ú–ï–¢–†–´ –í–ê–®–ï–ô –û–†–ò–ì–ò–ù–ê–õ–¨–ù–û–ô –î–ò–ê–ì–†–ê–ú–ú–´
const numLines = 21;
const secondsPerSide = 10;
const vertLineLength = 3000;

// –¢ARGET GAMMA = 1,000,000
const TARGET_GAMMA = 1000000.000;
const TARGET_V = Math.sqrt(1 - 1/(TARGET_GAMMA * TARGET_GAMMA));
const MAX_ANGLE = Math.asin(TARGET_V);

// –†–ê–°–ß–ï–¢ –†–ê–°–°–¢–û–Ø–ù–ò–ô
const lineSpacing = vertLineLength / (numLines - 1);
const halfSpacing = lineSpacing / 2;
const smallSpacing = lineSpacing / 10;

// –ú–£–õ–¨–¢–ò–¢–ê–ß –ü–ï–†–ï–ú–ï–ù–ù–´–ï
let touchStartDistance = null;
let touchStartAngle = null;
let touchStartCenterX = 0;
let touchStartCenterY = 0;
let touchStartScale = 0.3;
let touchStartAngleSystem = 0;
let touchStartOffsetX = 0;
let touchStartOffsetY = 0;
let touchStartWorldX = 0;
let touchStartWorldY = 0;

// –§—É–Ω–∫—Ü–∏–∏ —É–ø—Ä–∞–≤–ª–µ–Ω–∏—è (–≤–∞—à –æ—Ä–∏–≥–∏–Ω–∞–ª—å–Ω—ã–π –∫–æ–¥)...
function getTouchDistance(touches) {
  const dx = touches[0].clientX - touches[1].clientX;
  const dy = touches[0].clientY - touches[1].clientY;
  return Math.sqrt(dx * dx + dy * dy);
}

function getTouchAngle(touches) {
  const dx = touches[0].clientX - touches[1].clientX;
  const dy = touches[0].clientY - touches[1].clientY;
  return Math.atan2(dy, dx);
}

canvas.addEventListener('touchstart', (e) => {
  e.preventDefault();
  if (e.touches.length === 2) {
    const rect = canvas.getBoundingClientRect();
    const touch1 = e.touches[0];
    const touch2 = e.touches[1];
    touchStartDistance = getTouchDistance(e.touches);
    touchStartAngle = getTouchAngle(e.touches);
    touchStartCenterX = (touch1.clientX + touch2.clientX) / 2 - rect.left;
    touchStartCenterY = (touch1.clientY + touch2.clientY) / 2 - rect.top;
    touchStartScale = scale;
    touchStartAngleSystem = angle;
    touchStartOffsetX = offsetX;
    touchStartOffsetY = offsetY;
    touchStartWorldX = (touchStartCenterX - touchStartOffsetX) / touchStartScale;
    touchStartWorldY = (touchStartCenterY - touchStartOffsetY) / touchStartScale;
    dragging = false;
  } else if (e.touches.length === 1) {
    dragging = true;
    lastX = e.touches[0].clientX;
  }
}, { passive: false });

canvas.addEventListener('touchmove', (e) => {
  e.preventDefault();
  if (e.touches.length === 2 && touchStartDistance !== null && touchStartDistance > 0) {
    const rect = canvas.getBoundingClientRect();
    const touch1 = e.touches[0];
    const touch2 = e.touches[1];
    const currentDistance = getTouchDistance(e.touches);
    const currentAngle = getTouchAngle(e.touches);
    const currentCenterX = (touch1.clientX + touch2.clientX) / 2 - rect.left;
    const currentCenterY = (touch1.clientY + touch2.clientY) / 2 - rect.top;
    const zoomFactor = currentDistance / touchStartDistance;
    const newScale = Math.max(0.1, Math.min(5, touchStartScale * zoomFactor));
    const angleDelta = currentAngle - touchStartAngle;
    let newAngle = touchStartAngleSystem - angleDelta * 0.8;
    newAngle = Math.max(-MAX_ANGLE, Math.min(MAX_ANGLE, newAngle));
    const newOffsetX = currentCenterX - touchStartWorldX * newScale;
    const newOffsetY = currentCenterY - touchStartWorldY * newScale;
    scale = newScale;
    angle = newAngle;
    offsetX = newOffsetX;
    offsetY = newOffsetY;
    updateInfo();
  } else if (e.touches.length === 1 && dragging) {
    const dx = e.touches[0].clientX - lastX;
    angle += dx * 0.01;
    angle = Math.max(-MAX_ANGLE, Math.min(MAX_ANGLE, angle));
    lastX = e.touches[0].clientX;
    updateInfo();
  }
}, { passive: false });

canvas.addEventListener('touchend', (e) => {
  dragging = false;
  if (e.touches.length < 2) {
    touchStartDistance = null;
    touchStartAngle = null;
  }
});

canvas.addEventListener("pointerdown", e => {
  dragging = true;
  lastX = e.clientX;
});

canvas.addEventListener("pointermove", e => {
  if(dragging){
    const dx = e.clientX - lastX;
    angle += dx * 0.01;
    angle = Math.max(-MAX_ANGLE, Math.min(MAX_ANGLE, angle));
    lastX = e.clientX;
    updateInfo();
  }
});

canvas.addEventListener("pointerup", e => dragging = false);
canvas.addEventListener("pointerleave", e => dragging = false);

canvas.addEventListener("wheel", e => {
  e.preventDefault();
  const zoomFactor = 1.1;
  const rect = canvas.getBoundingClientRect();
  const mouseX = e.clientX - rect.left;
  const mouseY = e.clientY - rect.top;
  const worldX = (mouseX - offsetX) / scale;
  const worldY = (mouseY - offsetY) / scale;
  if (e.deltaY < 0) {
    scale *= zoomFactor;
  } else {
    scale /= zoomFactor;
  }
  scale = Math.max(0.1, Math.min(5, scale));
  offsetX = mouseX - worldX * scale;
  offsetY = mouseY - worldY * scale;
});

// –ö–Ω–æ–ø–∫–∞ –ø–µ—Ä–µ–∫–ª—é—á–µ–Ω–∏—è: M/E
document.getElementById('modeBtn').addEventListener('click', () => {
  showMinkowski = !showMinkowski;
  document.getElementById('modeBtn').textContent = showMinkowski ? 'E' : 'M';
});

document.getElementById('negBtn').addEventListener('click', () => {
  darkMode = !darkMode;
  document.body.classList.toggle('light-mode', !darkMode);
  document.getElementById('negBtn').textContent = darkMode ? '‚òÄ' : 'üåô';
});

// –§—É–Ω–∫—Ü–∏—è –¥–ª—è –ø–æ–¥–≥–æ–Ω–∫–∏ –º–∞—Å—à—Ç–∞–±–∞, —á—Ç–æ–±—ã –¥–∏–∞–≥—Ä–∞–º–º–∞ –ø–æ–º–µ—â–∞–ª–∞—Å—å –Ω–∞ —ç–∫—Ä–∞–Ω–µ
function fitToScreen() {
  // –†–∞–∑–º–µ—Ä –¥–∏–∞–≥—Ä–∞–º–º—ã (–æ–±–µ –¥–∏–∞–≥—Ä–∞–º–º—ã –æ–¥–∏–Ω–∞–∫–æ–≤–æ–≥–æ —Ä–∞–∑–º–µ—Ä–∞)
  const extent = lineSpacing * 10;
  const diagramSize = extent * 2; // –ü–æ–ª–Ω—ã–π —Ä–∞–∑–º–µ—Ä –¥–∏–∞–≥—Ä–∞–º–º—ã (–æ—Ç -extent –¥–æ +extent)
  
  // –ü–æ–ª—É—á–∞–µ–º —Ä–∞–∑–º–µ—Ä—ã canvas
  const canvasWidth = canvas.width;
  const canvasHeight = canvas.height;
  
  // –†–∞—Å—Å—á–∏—Ç—ã–≤–∞–µ–º –º–∞—Å—à—Ç–∞–± —Ç–∞–∫, —á—Ç–æ–±—ã –¥–∏–∞–≥—Ä–∞–º–º–∞ –ø–æ–º–µ—â–∞–ª–∞—Å—å —Å –Ω–µ–±–æ–ª—å—à–∏–º–∏ –æ—Ç—Å—Ç—É–ø–∞–º–∏
  const padding = 40; // –û—Ç—Å—Ç—É–ø—ã –æ—Ç –∫—Ä–∞–µ–≤ –≤ –ø–∏–∫—Å–µ–ª—è—Ö
  const availableWidth = canvasWidth - padding * 2;
  const availableHeight = canvasHeight - padding * 2;
  
  // –ú–∞—Å—à—Ç–∞–± –¥–ª—è —à–∏—Ä–∏–Ω—ã –∏ –≤—ã—Å–æ—Ç—ã
  const scaleX = availableWidth / diagramSize;
  const scaleY = availableHeight / diagramSize;
  
  // –ò—Å–ø–æ–ª—å–∑—É–µ–º –º–∏–Ω–∏–º–∞–ª—å–Ω—ã–π –º–∞—Å—à—Ç–∞–±, —á—Ç–æ–±—ã –¥–∏–∞–≥—Ä–∞–º–º–∞ –ø–æ–º–µ—â–∞–ª–∞—Å—å –ø–æ–ª–Ω–æ—Å—Ç—å—é
  scale = Math.min(scaleX, scaleY);
  
  // –¶–µ–Ω—Ç—Ä–∏—Ä—É–µ–º –¥–∏–∞–≥—Ä–∞–º–º—É
  offsetX = canvasWidth / 2;
  offsetY = canvasHeight / 2;
}

document.getElementById('zoomReset').addEventListener('click', () => {
  fitToScreen();
});

// –ò–°–ü–†–ê–í–õ–ï–ù–ù–ê–Ø –ö–ù–û–ü–ö–ê –ü–û–õ–ù–û–≠–ö–†–ê–ù–ù–û–ì–û –†–ï–ñ–ò–ú–ê
const fullscreenBtn = document.getElementById('fullscreen');
// –ò—Å–ø–æ–ª—å–∑—É–µ–º –±–æ–ª–µ–µ –Ω–∞–¥–µ–∂–Ω—ã–π —Å–∏–º–≤–æ–ª –¥–ª—è –∫–Ω–æ–ø–∫–∏ –ø–æ–ª–Ω–æ—ç–∫—Ä–∞–Ω–Ω–æ–≥–æ —Ä–µ–∂–∏–º–∞
fullscreenBtn.innerHTML = '<svg width="18" height="18" viewBox="0 0 24 24" fill="currentColor"><path d="M7 14H5v5h5v-2H7v-3zm-2-4h2V7h3V5H5v5zm12 7h-3v2h5v-5h-2v3zM14 5v2h3v3h2V5h-5z"/></svg>';

fullscreenBtn.addEventListener('click', () => {
  if (!document.fullscreenElement && !document.webkitFullscreenElement) {
    if (document.documentElement.requestFullscreen) {
      document.documentElement.requestFullscreen();
    } else if (document.documentElement.webkitRequestFullscreen) {
      document.documentElement.webkitRequestFullscreen();
    } else if (document.documentElement.mozRequestFullScreen) {
      document.documentElement.mozRequestFullScreen();
    } else if (document.documentElement.msRequestFullscreen) {
      document.documentElement.msRequestFullscreen();
    }
  } else {
    if (document.exitFullscreen) {
      document.exitFullscreen();
    } else if (document.webkitExitFullscreen) {
      document.webkitExitFullscreen();
    } else if (document.mozCancelFullScreen) {
      document.mozCancelFullScreen();
    } else if (document.msExitFullscreen) {
      document.msExitFullscreen();
    }
  }
});

// –û–±–Ω–æ–≤–ª—è–µ–º –∏–∫–æ–Ω–∫—É –ø—Ä–∏ –∏–∑–º–µ–Ω–µ–Ω–∏–∏ –ø–æ–ª–Ω–æ—ç–∫—Ä–∞–Ω–Ω–æ–≥–æ —Ä–µ–∂–∏–º–∞
document.addEventListener('fullscreenchange', updateFullscreenIcon);
document.addEventListener('webkitfullscreenchange', updateFullscreenIcon);
document.addEventListener('mozfullscreenchange', updateFullscreenIcon);
document.addEventListener('MSFullscreenChange', updateFullscreenIcon);

function updateFullscreenIcon() {
  const isFullscreen = document.fullscreenElement || 
                       document.webkitFullscreenElement || 
                       document.mozFullScreenElement || 
                       document.msFullscreenElement;
  
  if (isFullscreen) {
    fullscreenBtn.innerHTML = '<svg width="18" height="18" viewBox="0 0 24 24" fill="currentColor"><path d="M5 16h3v3h2v-5H5v2zm3-8H5v2h5V5H8v3zm6 11h2v-3h3v-2h-5v5zm2-11V5h-2v5h5V8h-3z"/></svg>';
  } else {
    fullscreenBtn.innerHTML = '<svg width="18" height="18" viewBox="0 0 24 24" fill="currentColor"><path d="M7 14H5v5h5v-2H7v-3zm-2-4h2V7h3V5H5v5zm12 7h-3v2h5v-5h-2v3zM14 5v2h3v3h2V5h-5z"/></svg>';
  }
}

function updateInfo() {
  const velocity = Math.sin(angle);
  let velocityStr;
  if (Math.abs(velocity) < 0.0001) {
    velocityStr = "0.000c";
  } else {
    const absV = Math.abs(velocity);
    if (Math.abs(Math.abs(angle) - MAX_ANGLE) < 0.0000001) {
      // –î–ª—è –º–∞–∫—Å–∏–º–∞–ª—å–Ω–æ–π —Å–∫–æ—Ä–æ—Å—Ç–∏ –ø–æ–∫–∞–∑—ã–≤–∞–µ–º 8 –∑–Ω–∞–∫–æ–≤ –ø–æ—Å–ª–µ –∑–∞–ø—è—Ç–æ–π –≤–º–µ—Å—Ç–æ 12
      velocityStr = TARGET_V.toFixed(8) + "c";
    } else if (absV > 0.999999) {
      velocityStr = absV.toFixed(8) + "c"; // –£–º–µ–Ω—å—à–∏–ª–∏ —Å 12 –¥–æ 8 –∑–Ω–∞–∫–æ–≤
    } else if (absV > 0.999) {
      velocityStr = absV.toFixed(6) + "c";
    } else if (absV > 0.99) {
      velocityStr = absV.toFixed(4) + "c"; // –£–º–µ–Ω—å—à–∏–ª–∏ —Å 6 –¥–æ 4 –∑–Ω–∞–∫–æ–≤
    } else {
      velocityStr = absV.toFixed(3) + "c";
    }
    if (velocity < 0) velocityStr = "-" + velocityStr;
  }
  
  let gamma = 1;
  const v = Math.abs(velocity);
  if (v < 0.999999999999) {
    gamma = 1 / Math.sqrt(1 - v * v);
  } else {
    gamma = TARGET_GAMMA;
  }
  
  let gammaStr;
  if (Math.abs(Math.abs(angle) - MAX_ANGLE) < 0.0000001) {
    gammaStr = TARGET_GAMMA.toFixed(3);
  } else if (gamma >= 1000000) {
    gammaStr = gamma.toExponential(2); // –ò—Å–ø–æ–ª—å–∑—É–µ–º —ç–∫—Å–ø–æ–Ω–µ–Ω—Ü–∏–∞–ª—å–Ω—É—é –∑–∞–ø–∏—Å—å –¥–ª—è –æ—á–µ–Ω—å –±–æ–ª—å—à–∏—Ö –∑–Ω–∞—á–µ–Ω–∏–π
  } else if (gamma >= 1000) {
    gammaStr = gamma.toFixed(1); // –£–º–µ–Ω—å—à–∏–ª–∏ –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ –∑–Ω–∞–∫–æ–≤
  } else {
    gammaStr = gamma.toFixed(3);
  }
  
  document.getElementById('speedValue').textContent = velocityStr;
  document.getElementById('gammaValue').textContent = gammaStr;
  
  const speedValue = document.getElementById('speedValue');
  const absV = Math.abs(velocity);
  if (absV < 0.3) {
    speedValue.style.color = darkMode ? '#0f0' : '#080';
  } else if (absV < 0.7) {
    speedValue.style.color = darkMode ? '#ff0' : '#880';
  } else if (absV < 0.95) {
    speedValue.style.color = darkMode ? '#f80' : '#c60';
  } else {
    speedValue.style.color = darkMode ? '#f00' : '#c00';
  }
}

function resize() {
  canvas.width = window.innerWidth;
  canvas.height = window.innerHeight;
  fitToScreen(); // –ü—Ä–∏ –∏–∑–º–µ–Ω–µ–Ω–∏–∏ —Ä–∞–∑–º–µ—Ä–∞ –æ–∫–Ω–∞ —Ç–æ–∂–µ –ø–æ–¥–≥–æ–Ω—è–µ–º –º–∞—Å—à—Ç–∞–±
}
window.addEventListener("resize", resize);
resize();

// === –û–ë–©–ò–ï –§–£–ù–ö–¶–ò–ò –î–õ–Ø –û–ë–ï–ò–• –î–ò–ê–ì–†–ê–ú–ú ===
function toScreen(x, y) {
  return {
    x: x * scale + offsetX,
    y: y * scale + offsetY
  };
}

function getColor(darkColor, lightColor) {
  return darkMode ? darkColor : lightColor;
}

function drawLine(x1, y1, x2, y2, darkColor, lightColor, width) {
  const p1 = toScreen(x1, y1);
  const p2 = toScreen(x2, y2);
  ctx.strokeStyle = getColor(darkColor, lightColor);
  ctx.lineWidth = width;
  ctx.beginPath();
  ctx.moveTo(p1.x, p1.y);
  ctx.lineTo(p2.x, p2.y);
  ctx.stroke();
}

function drawDashedLine(x1, y1, x2, y2, darkColor, lightColor, width, dashPattern = [5, 5]) {
  const p1 = toScreen(x1, y1);
  const p2 = toScreen(x2, y2);
  ctx.strokeStyle = getColor(darkColor, lightColor);
  ctx.lineWidth = width;
  ctx.setLineDash(dashPattern);
  ctx.beginPath();
  ctx.moveTo(p1.x, p1.y);
  ctx.lineTo(p2.x, p2.y);
  ctx.stroke();
  ctx.setLineDash([]);
}

function drawMark(px, py, dirX, dirY, length, darkColor, lightColor, width, style = "solid") {
  const p = toScreen(px, py);
  const d = toScreen(px + dirX * length/2, py + dirY * length/2);
  const d2 = toScreen(px - dirX * length/2, py - dirY * length/2);
  ctx.strokeStyle = getColor(darkColor, lightColor);
  ctx.lineWidth = width;
  if (style === "dashed") {
    ctx.setLineDash([3, 2]);
  } else {
    ctx.setLineDash([]);
  }
  ctx.beginPath();
  ctx.moveTo(d2.x, d2.y);
  ctx.lineTo(d.x, d.y);
  ctx.stroke();
  ctx.setLineDash([]);
}

function drawPoint(px, py, radius, darkColor, lightColor) {
  const p = toScreen(px, py);
  ctx.fillStyle = getColor(darkColor, lightColor);
  ctx.beginPath();
  ctx.arc(p.x, p.y, radius, 0, Math.PI * 2);
  ctx.fill();
}

function drawText(text, px, py, darkColor, lightColor, fontSize = 10, align = "center") {
  if (scale < 0.3) return;
  const p = toScreen(px, py);
  ctx.font = `${fontSize}px Arial`;
  ctx.fillStyle = getColor(darkColor, lightColor);
  ctx.textAlign = align;
  ctx.textBaseline = "middle";
  ctx.fillText(text, p.x, p.y);
}

// === –í–ê–®–ê –û–†–ò–ì–ò–ù–ê–õ–¨–ù–ê–Ø –î–ò–ê–ì–†–ê–ú–ú–ê (E) ===
function drawOriginalDiagram() {
  const cx = 0;
  const cy = 0;
  const cosA = Math.cos(angle);
  const sinA = Math.sin(angle);

  // –ò—Å–ø–æ–ª—å–∑—É–µ–º —Ç–∞–∫–æ–π –∂–µ —Ä–∞–∑–º–µ—Ä –∫–∞–∫ –≤ M: 10 —à–∞–≥–æ–≤ —Å–µ—Ç–∫–∏ –≤ –∫–∞–∂–¥—É—é —Å—Ç–æ—Ä–æ–Ω—É
  const extent = lineSpacing * 10;
  
  drawLine(-extent, cy, extent, cy, "#0ff", "#08f", 1);
  
  const ctX0 = cx - sinA * extent;
  const ctY0 = cy - cosA * extent;
  const ctX1 = cx + sinA * extent;
  const ctY1 = cy + cosA * extent;

  const xX0 = cx - cosA * extent;
  const xY0 = cy + sinA * extent;
  const xX1 = cx + cosA * extent;
  const xY1 = cy - sinA * extent;

  drawLine(ctX0, ctY0, ctX1, ctY1, "#0ff", "#08f", 1);
  drawLine(xX0, xY0, xX1, xY1, "#888", "#666", 1);

  const ctDirX = ctX1 - ctX0;
  const ctDirY = ctY1 - ctY0;
  const ctLength = Math.sqrt(ctDirX*ctDirX + ctDirY*ctDirY);
  const ctUnitX = ctDirX / ctLength;
  const ctUnitY = ctDirY / ctLength;
  const ctPerpX = -ctUnitY;
  const ctPerpY = ctUnitX;
  
  const xDirX = xX1 - xX0;
  const xDirY = xY1 - xY0;
  const xLength = Math.sqrt(xDirX*xDirX + xDirY*xDirY);
  const xUnitX = xDirX / xLength;
  const xUnitY = xDirY / xLength;
  const xPerpX = -xUnitY;
  const xPerpY = xUnitX;
  
  for(let sec = 1; sec <= secondsPerSide; sec++) {
    const distance = sec * lineSpacing;
    
    const bigX1 = distance * ctUnitX;
    const bigY1 = distance * ctUnitY;
    drawMark(bigX1, bigY1, ctPerpX, ctPerpY, 14, "#0ff", "#08f", 1.5);
    if (scale > 0.5) {
      drawText((-sec).toString(), 
               bigX1 + ctPerpX * 15,
               bigY1 + ctPerpY * 15, 
               "#0ff", "#08f", 10);
    }
    
    const bigX2 = -distance * ctUnitX;
    const bigY2 = -distance * ctUnitY;
    drawMark(bigX2, bigY2, ctPerpX, ctPerpY, 14, "#0ff", "#08f", 1.5);
    if (scale > 0.5) {
      drawText(sec.toString(), 
               bigX2 - ctPerpX * 15,
               bigY2 - ctPerpY * 15, 
               "#0ff", "#08f", 10);
    }
    
    const halfDistance = distance - halfSpacing;
    const halfX1 = halfDistance * ctUnitX;
    const halfY1 = halfDistance * ctUnitY;
    drawMark(halfX1, halfY1, ctPerpX, ctPerpY, 10, "#0aa", "#06a", 1.0, "dashed");
    
    const halfX2 = -halfDistance * ctUnitX;
    const halfY2 = -halfDistance * ctUnitY;
    drawMark(halfX2, halfY2, ctPerpX, ctPerpY, 10, "#0aa", "#06a", 1.0, "dashed");
  }
  
  // –ú–∞–ª–µ–Ω—å–∫–∏–µ —Ç–æ—á–∫–∏ –Ω–∞ –≥–æ–ª—É–±–æ–π –ª–∏–Ω–∏–∏ - –ø–æ–∫–∞–∑—ã–≤–∞–µ–º —Ç–æ–ª—å–∫–æ –ø—Ä–∏ —É–≤–µ–ª–∏—á–µ–Ω–∏–∏
  if (scale > 0.7) {
    const smallMarksPerSide = secondsPerSide * 10;
    for(let tenth = 1; tenth <= smallMarksPerSide; tenth++) {
      if (tenth % 5 === 0) continue;
      
      const distance = tenth * smallSpacing;
      const smallX1 = distance * ctUnitX;
      const smallY1 = distance * ctUnitY;
      
      drawPoint(smallX1, smallY1, 2, "#099", "#057");
      
      const smallX2 = -distance * ctUnitX;
      const smallY2 = -distance * ctUnitY;
      drawPoint(smallX2, smallY2, 2, "#099", "#057");
    }
  }

  // –†–∏—Å—É–µ–º –≤–µ—Ä—Ç–∏–∫–∞–ª—å–Ω—ã–µ –ª–∏–Ω–∏–∏ (–æ—Å–∏ x) - —Ç–µ–ø–µ—Ä—å —Ç–æ–∂–µ –æ–≥—Ä–∞–Ω–∏—á–∏–≤–∞–µ–º –¥–æ extent
  for(let i = -10; i <= 10; i++){ 
    const t = i / 10; 
    const px = xX0 + (xX1 - xX0) * (0.5 + t/2); 
    const py = xY0 + (xY1 - xY0) * (0.5 + t/2);
    
    drawLine(
      px, py - extent,
      px, py + extent,
      "#888", "#666",
      1
    );
    
    for(let sec = 1; sec <= secondsPerSide; sec++) {
      const distance = sec * lineSpacing;
      
      const upX = px;
      const upY = py - distance;
      drawMark(upX, upY, 1, 0, 12, "#888", "#666", 1.5);
      if (scale > 0.5) {
        drawText(sec.toString(), upX - 8, upY, "#888", "#666", 10, "right");
      }
      
      const downX = px;
      const downY = py + distance;
      drawMark(downX, downY, 1, 0, 12, "#888", "#666", 1.5);
      if (scale > 0.5) {
        drawText((-sec).toString(), downX + 8, downY, "#888", "#666", 10, "left");
      }
      
      const halfDistance = distance - halfSpacing;
      const halfUpX = px;
      const halfUpY = py - halfDistance;
      drawMark(halfUpX, halfUpY, 1, 0, 9, "#888", "#666", 1.0, "dashed");
      
      const halfDownX = px;
      const halfDownY = py + halfDistance;
      drawMark(halfDownX, halfDownY, 1, 0, 9, "#888", "#666", 1.0, "dashed");
    }
    
    // –ú–∞–ª–µ–Ω—å–∫–∏–µ —Ç–æ—á–∫–∏ –Ω–∞ –≤–µ—Ä—Ç–∏–∫–∞–ª—å–Ω—ã—Ö –æ—Å—è—Ö - –ø–æ–∫–∞–∑—ã–≤–∞–µ–º —Ç–æ–ª—å–∫–æ –ø—Ä–∏ —É–≤–µ–ª–∏—á–µ–Ω–∏–∏
    if (scale > 0.7) {
      for(let tenth = 1; tenth <= secondsPerSide * 10; tenth++) {
        if (tenth % 5 === 0) continue;
        
        const distance = tenth * smallSpacing;
        const upX = px;
        const upY = py - distance;
        
        drawPoint(upX, upY, 1.5, "#888", "#666");
        
        const downX = px;
        const downY = py + distance;
        drawPoint(downX, downY, 1.5, "#888", "#666");
      }
    }
    
    if (scale > 0.7 && i !== 0) {
      drawText(i.toString(), px, py + 20, "#888", "#666", 10);
    }
  }

  // –¶–ï–ù–¢–† - –£–ú–ï–ù–¨–®–ï–ù–ù–ê–Ø –ë–ï–õ–ê–Ø –¢–û–ß–ö–ê (–±—ã–ª–æ 4, —Å—Ç–∞–ª–æ 2)
  const center = toScreen(0, 0);
  ctx.fillStyle = getColor("#fff", "#000");
  ctx.beginPath();
  ctx.arc(center.x, center.y, 2, 0, Math.PI * 2);
  ctx.fill();
}

// === –î–ò–ê–ì–†–ê–ú–ú–ê –ú–ò–ù–ö–û–í–°–ö–û–ì–û (M) - —Å –ø—Ä–∞–≤–∏–ª—å–Ω—ã–º –º–∞—Å—à—Ç–∞–±–æ–º ===
function drawMinkowskiDiagram() {
  // –¢–µ–ø–µ—Ä—å –æ–±–µ –¥–∏–∞–≥—Ä–∞–º–º—ã –æ–¥–∏–Ω–∞–∫–æ–≤–æ–≥–æ —Ä–∞–∑–º–µ—Ä–∞: 10 —à–∞–≥–æ–≤ —Å–µ—Ç–∫–∏ –≤ –∫–∞–∂–¥—É—é —Å—Ç–æ—Ä–æ–Ω—É
  const extent = lineSpacing * 10;
  
  // 1. –û–°–ù–û–í–ù–´–ï –û–°–ò (–ª–∞–±–æ—Ä–∞—Ç–æ—Ä–Ω–∞—è —Å–∏—Å—Ç–µ–º–∞) - –ì–û–õ–£–ë–´–ï –¢–û–ù–ö–ò–ï –õ–ò–ù–ò–ò
  drawLine(-extent, 0, extent, 0, "#0ff", "#08f", 0.5); // –û—Å—å x - –≥–æ–ª—É–±–∞—è
  drawLine(0, -extent, 0, extent, "#0ff", "#08f", 0.5); // –û—Å—å ct - –≥–æ–ª—É–±–∞—è
  
  // 2. –°–í–ï–¢–û–í–´–ï –ö–û–ù–£–°–´ (45¬∞ –ª–∏–Ω–∏–∏) - –û–ß–ï–ù–¨ –¢–û–ù–ö–ò–ï –ò–õ–ò –®–¢–†–ò–•–û–í–ê–ù–ù–´–ï
  // –ò—Å–ø–æ–ª—å–∑—É–µ–º —Ç–æ–Ω–∫–∏–µ –ø—É–Ω–∫—Ç–∏—Ä–Ω—ã–µ –ª–∏–Ω–∏–∏ –¥–ª—è —Å–≤–µ—Ç–æ–≤—ã—Ö –∫–æ–Ω—É—Å–æ–≤
  drawDashedLine(-extent, -extent, extent, extent, "#ff0", "#880", 0.3, [1, 3]); // ct = x - –æ—á–µ–Ω—å —Ç–æ–Ω–∫–∏–π –ø—É–Ω–∫—Ç–∏—Ä
  drawDashedLine(-extent, extent, extent, -extent, "#ff0", "#880", 0.3, [1, 3]); // ct = -x - –æ—á–µ–Ω—å —Ç–æ–Ω–∫–∏–π –ø—É–Ω–∫—Ç–∏—Ä
  
  // 3. –ö–û–û–†–î–ò–ù–ê–¢–ù–ê–Ø –°–ï–¢–ö–ê –ª–∞–±–æ—Ä–∞—Ç–æ—Ä–Ω–æ–π —Å–∏—Å—Ç–µ–º—ã - –ì–û–õ–£–ë–ê–Ø –°–ï–¢–ö–ê
  const gridStep = lineSpacing;
  
  // –°–ï–¢–ö–ê –õ–ê–ë–û–†–ê–¢–û–†–ù–û–ô –°–ò–°–¢–ï–ú–´ - –ì–û–õ–£–ë–ê–Ø
  for (let i = -Math.floor(extent/gridStep); i <= Math.floor(extent/gridStep); i++) {
    if (i === 0) continue;
    const x = i * gridStep;
    // –í–µ—Ä—Ç–∏–∫–∞–ª—å–Ω—ã–µ –ª–∏–Ω–∏–∏ –ª–∞–±–æ—Ä–∞—Ç–æ—Ä–Ω–æ–π —Å–∏—Å—Ç–µ–º—ã (–ø–æ—Å—Ç–æ—è–Ω–Ω—ã–π x)
    drawDashedLine(x, -extent, x, extent, "#0aa", "#06a", 0.4, [3, 3]);
    // –ì–æ—Ä–∏–∑–æ–Ω—Ç–∞–ª—å–Ω—ã–µ –ª–∏–Ω–∏–∏ –ª–∞–±–æ—Ä–∞—Ç–æ—Ä–Ω–æ–π —Å–∏—Å—Ç–µ–º—ã (–ø–æ—Å—Ç–æ—è–Ω–Ω—ã–π ct)
    drawDashedLine(-extent, x, extent, x, "#0aa", "#06a", 0.4, [3, 3]);
  }
  
  // 4. –û–°–ò –î–í–ò–ñ–£–©–ï–ô–°–Ø –°–ò–°–¢–ï–ú–´ (–ø—Ä–µ–æ–±—Ä–∞–∑–æ–≤–∞–Ω–∏—è –õ–æ—Ä–µ–Ω—Ü–∞)
  const beta = Math.sin(angle);
  
  // –ò—Å–ø–æ–ª—å–∑—É–µ–º –û–ì–†–ê–ù–ò–ß–ï–ù–ù–£–Æ –±–µ—Ç–∞ –¥–ª—è –≤–∏–∑—É–∞–ª–∏–∑–∞—Ü–∏–∏, —á—Ç–æ–±—ã –∏–∑–±–µ–∂–∞—Ç—å –∑–∞–ª–∏–ø–∞–Ω–∏—è
  // –ü—Ä–∏ 45 –≥—Ä–∞–¥—É—Å–∞—Ö (0.707c) –∏ –≤—ã—à–µ –∏—Å–ø–æ–ª—å–∑—É–µ–º –ø–ª–∞–≤–Ω–æ–µ –æ–≥—Ä–∞–Ω–∏—á–µ–Ω–∏–µ
  const visBetaLimit = 0.999;
  let visBeta = beta;
  
  // –ü–ª–∞–≤–Ω–æ–µ –æ–≥—Ä–∞–Ω–∏—á–µ–Ω–∏–µ –ø—Ä–∏ –ø—Ä–∏–±–ª–∏–∂–µ–Ω–∏–∏ –∫ 45¬∞ –∏ –≤—ã—à–µ
  const absBeta = Math.abs(beta);
  if (absBeta > 0.707) {
    // –ü–ª–∞–≤–Ω–∞—è –∏–Ω—Ç–µ—Ä–ø–æ–ª—è—Ü–∏—è –º–µ–∂–¥—É 0.707 –∏ visBetaLimit
    const t = (absBeta - 0.707) / (0.999 - 0.707);
    const limitedBeta = 0.707 + (visBetaLimit - 0.707) * t;
    visBeta = Math.min(absBeta, limitedBeta) * Math.sign(beta);
  }
  
  const visGamma = 1 / Math.sqrt(1 - visBeta * visBeta);
  
  // –ï–¥–∏–Ω–∏—á–Ω—ã–µ –≤–µ–∫—Ç–æ—Ä—ã –¥–ª—è –¥–≤–∏–∂—É—â–µ–π—Å—è —Å–∏—Å—Ç–µ–º—ã —Å –æ–≥—Ä–∞–Ω–∏—á–µ–Ω–Ω–æ–π –±–µ—Ç–∞
  const ctPrimeX = visBeta * visGamma; // ct' –æ—Å—å
  const ctPrimeY = visGamma;
  const xPrimeX = visGamma;         // x' –æ—Å—å  
  const xPrimeY = visBeta * visGamma;
  
  // –î–æ–ø–æ–ª–Ω–∏—Ç–µ–ª—å–Ω–æ–µ –æ–≥—Ä–∞–Ω–∏—á–µ–Ω–∏–µ –≥–∞–º–º—ã –¥–ª—è –ø—Ä–µ–¥–æ—Ç–≤—Ä–∞—â–µ–Ω–∏—è –∑–∞–ª–∏–ø–∞–Ω–∏—è
  const maxGamma = 50;
  const drawGamma = Math.min(visGamma, maxGamma);
  const drawBeta = Math.sqrt(1 - 1/(drawGamma * drawGamma)) * Math.sign(visBeta);
  
  const drawCtPrimeX = drawBeta * drawGamma;
  const drawCtPrimeY = drawGamma;
  const drawXPrimeX = drawGamma;
  const drawXPrimeY = drawBeta * drawGamma;
  
  // –û—Å–∏ –¥–≤–∏–∂—É—â–µ–π—Å—è —Å–∏—Å—Ç–µ–º—ã - –°–ï–†–´–ô –¶–í–ï–¢
  // –†–∏—Å—É–µ–º ct' –æ—Å—å
  drawLine(-drawCtPrimeX * extent, -drawCtPrimeY * extent, 
           drawCtPrimeX * extent, drawCtPrimeY * extent, 
           "#888", "#666", 1.5); // ct' –æ—Å—å - —Å–µ—Ä–∞—è
  
  // –†–∏—Å—É–µ–º x' –æ—Å—å
  drawLine(-drawXPrimeX * extent, -drawXPrimeY * extent, 
           drawXPrimeX * extent, drawXPrimeY * extent, 
           "#888", "#666", 1.5); // x' –æ—Å—å - —Å–µ—Ä–∞—è
  
  // 5. –ö–û–û–†–î–ò–ù–ê–¢–ù–ê–Ø –°–ï–¢–ö–ê –¥–≤–∏–∂—É—â–µ–π—Å—è —Å–∏—Å—Ç–µ–º—ã - –°–ï–†–ê–Ø –°–ï–¢–ö–ê
  for (let i = -Math.floor(extent/gridStep); i <= Math.floor(extent/gridStep); i++) {
    const offset = i * gridStep;
    
    // –õ–∏–Ω–∏–∏ –ø–æ—Å—Ç–æ—è–Ω–Ω–æ–≥–æ ct' (–ø–∞—Ä–∞–ª–ª–µ–ª—å–Ω–æ x') - –°–ï–†–ê–Ø –°–ï–¢–ö–ê
    const x1 = -drawXPrimeX * extent + drawCtPrimeX * offset;
    const y1 = -drawXPrimeY * extent + drawCtPrimeY * offset;
    const x2 = drawXPrimeX * extent + drawCtPrimeX * offset;
    const y2 = drawXPrimeY * extent + drawCtPrimeY * offset;
    
    // –†–∏—Å—É–µ–º –≤—Å–µ–≥–¥–∞
    const p1 = toScreen(x1, y1);
    const p2 = toScreen(x2, y2);
    ctx.strokeStyle = getColor("#888", "#666");
    ctx.lineWidth = 0.7;
    
    // –ü—Ä–æ–≤–µ—Ä—è–µ–º —É–≥–æ–ª –Ω–∞–∫–ª–æ–Ω–∞
    const slope = Math.abs((y2 - y1) / (x2 - x1));
    const angleDiff = Math.abs(Math.atan(slope) - Math.PI/4);
    
    if (angleDiff < 0.05 && Math.abs(visBeta) > 0.7) {
      // –ï—Å–ª–∏ –æ—á–µ–Ω—å –±–ª–∏–∑–∫–æ –∫ —Å–≤–µ—Ç–æ–≤–æ–π –ª–∏–Ω–∏–∏, –¥–µ–ª–∞–µ–º –ø—É–Ω–∫—Ç–∏—Ä
      ctx.setLineDash([2, 4]);
    } else {
      ctx.setLineDash([4, 4]);
    }
    
    ctx.beginPath();
    ctx.moveTo(p1.x, p1.y);
    ctx.lineTo(p2.x, p2.y);
    ctx.stroke();
    ctx.setLineDash([]);
    
    // –õ–∏–Ω–∏–∏ –ø–æ—Å—Ç–æ—è–Ω–Ω–æ–≥–æ x' (–ø–∞—Ä–∞–ª–ª–µ–ª—å–Ω–æ ct') - –°–ï–†–ê–Ø –°–ï–¢–ö–ê
    const x3 = -drawCtPrimeX * extent + drawXPrimeX * offset;
    const y3 = -drawCtPrimeY * extent + drawXPrimeY * offset;
    const x4 = drawCtPrimeX * extent + drawXPrimeX * offset;
    const y4 = drawCtPrimeY * extent + drawXPrimeY * offset;
    
    // –†–∏—Å—É–µ–º –≤—Å–µ–≥–¥–∞
    const p3 = toScreen(x3, y3);
    const p4 = toScreen(x4, y4);
    ctx.strokeStyle = getColor("#888", "#666");
    ctx.lineWidth = 0.7;
    
    // –ü—Ä–æ–≤–µ—Ä—è–µ–º —É–≥–æ–ª –Ω–∞–∫–ª–æ–Ω–∞
    const slope2 = Math.abs((y4 - y3) / (x4 - x3));
    const angleDiff2 = Math.abs(Math.atan(slope2) - Math.PI/4);
    
    if (angleDiff2 < 0.05 && Math.abs(visBeta) > 0.7) {
      // –ï—Å–ª–∏ –æ—á–µ–Ω—å –±–ª–∏–∑–∫–æ –∫ —Å–≤–µ—Ç–æ–≤–æ–π –ª–∏–Ω–∏–∏, –¥–µ–ª–∞–µ–º –ø—É–Ω–∫—Ç–∏—Ä
      ctx.setLineDash([2, 4]);
    } else {
      ctx.setLineDash([4, 4]);
    }
    
    ctx.beginPath();
    ctx.moveTo(p3.x, p3.y);
    ctx.lineTo(p4.x, p4.y);
    ctx.stroke();
    ctx.setLineDash([]);
  }
  
  // 6. –ì–ò–ü–ï–†–ë–û–õ–´ –£–ë–†–ê–ù–´ - –±–æ–ª—å—à–µ –Ω–µ —Ä–∏—Å—É—é—Ç—Å—è
  
  // 7. –¶–ï–ù–¢–† - –£–ú–ï–ù–¨–®–ï–ù–ù–ê–Ø –ë–ï–õ–ê–Ø –¢–û–ß–ö–ê (–±—ã–ª–æ 4, —Å—Ç–∞–ª–æ 2)
  const center = toScreen(0, 0);
  ctx.fillStyle = getColor("#fff", "#000");
  ctx.beginPath();
  ctx.arc(center.x, center.y, 2, 0, Math.PI * 2);
  ctx.fill();
}

// === –ì–õ–ê–í–ù–´–ô –¶–ò–ö–õ –û–¢–†–ò–°–û–í–ö–ò ===
function animate() {
  ctx.clearRect(0, 0, canvas.width, canvas.height);
  
  if (showMinkowski) {
    drawMinkowskiDiagram();
  } else {
    drawOriginalDiagram();
  }
  
  requestAnimationFrame(animate);
}

// –ó–∞–ø—É—Å–∫ –∞–Ω–∏–º–∞—Ü–∏–∏
updateInfo();
animate();
</script>
</body>
</html>
